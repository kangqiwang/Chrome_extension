const async = require('async')
const Mongo = require('../../mongo')
const md5 = require('md5')
const redis = require('../../redis').handle
const AllSuppliers = require('./allSuppliers')
const IdToSupplier = require('./idToSupplier')
const DomainToID = require('./domainToId')
const ApifyType = require('./apifyTypes')
const walmatCatIds = require('./walmatCatIds')
const fs = require('fs')


module.exports = {

    generate(config, next) {        

        this.config = config
        this.redisHandle = redis(config.redis)
        this.AS = new AllSuppliers(this.config.redis)
        this.IDTOSUPPLIER = new IdToSupplier(this.config.redis)
        this.D2ID = new DomainToID(this.config.redis)
        this.APIFYTYPES = new ApifyType(this.config.redis)

        this.redisHandle.get("CACHEOK", (err, data) => {
            if (err) {
                console.error(err)
            } else {
                if (data === null || config.force) {
                    console.log("Creating Supplier Cache")
                    this.createCache(next)
                } else {
                    console.log('Supplier Cache OK')
                    next()
                }
            }
        })
    },

    domainToId(country, domain, next) {
        this.D2ID.getId(country, domain, next)
    },

    getAll(country, next) {
        this.AS.getSupplier(country, next)
    },

    getBarcoded(country, next) {
        this.AS.getBarcoded(country, next)
    },

    getName(country, id, next) {
        this.IDTOSUPPLIER.getName(country, id, next)
    },

    getAllInfo(country, id, next) {
        this.IDTOSUPPLIER.getAllInfo(country, id, next)
    },

    getDomain(country, id, next) {
        this.IDTOSUPPLIER.getDomain(country, id, next)
    },

    getLiveSuppliers(country, next) {
        this.getAll(country, next)
    },

    getNextToRun(country, type, next) {        
        let list = "APIFY:" + country.toLowerCase() + ":" + type      
        this.redisHandle.brpoplpush(list, list, 0, (err, supplierType) => {
            if (err) {
                next(err)
            } else {
                this.redisHandle.hgetall(supplierType, (err, data) => {
                    if (err) {
                        next(err)
                    } else {
                        next(null, {
                            ids: JSON.parse(data.SUPPLIER_IDS),
                            hostConfig: JSON.parse(data.STRING_ID),
                            names: JSON.parse(data.NAMES)
                        })
                    }
                })
            }
        })
    },

    createCache(next) {
        this.MDB = new Mongo(this.config.mongo)

        let countries = ["uk", "us"]
        let total = countries.length

        countries.map((country) => {
            console.log("SUPPLIER CACHE FOR ", country)
            this.countryCache(country, () => {
                total--;
                if (total === 0) {
                    this.redisHandle.set("CACHEOK", true)
                    next()
                }
            })
        })
    },

    countryCache(country, next) {
        this.MDB.conn(country + "suppliers", (err, collection) => {
            if (err) {
                console.error(err)
                next(err)
            } else {
                this.find(collection, country, () => {
                    this.aggs(collection, country, () => {
                        next()
                    })
                })
            }
        })
    },

    find(collection, country, next) {

        collection.find({
            live: true
        }, {
                _id: 1, name: 1, domain: 1, barcoded: 1
            })
            .sort({ name: 1 })
            .toArray((err, data) => {
                if (err) {
                    next(err)
                    console.error(err)
                } else {
                    let lookup = {}
                    let barcoded = {}
                    data.map((sup) => {
                        let id = sup._id.toString()
                        lookup[id] = sup
                        lookup[id].id = sup._id
                        this.D2ID.setSupplier(country, sup.domain, id)
                        this.IDTOSUPPLIER.setSupplier(country, id, sup.domain, sup.name)
                        if (sup.barcoded) {
                            barcoded[id] = sup
                            barcoded[id].id = sup._id

                        }
                    })
                    this.AS.setSupplier(country, lookup)
                    this.AS.setBarcodedSupplier(country, barcoded)

                    next()
                }
            })
    },

    aggs(collection, country, next) {

        let match = {
            live: true
        }

        let walmatCIds = walmatCatIds()

        if (country === 'us') {
            match = { $or: [{ live: true }, { _id: { $in: walmatCIds } }] }
        }

        collection.aggregate([{
            $match: match
        }, {
            $group: {
                _id: {
                    "anticaptchaactor": "$anticaptchaactor",
                    "checkerblacklist": "$checkerblacklist",
                    "clickhosts": "$clickhosts",
                    "falsejqueryinject": "$falsejqueryinject",
                    "lazyloading": "$lazyloading",
                    "shader10proxies": "$shader10proxies",
                    "shaderproxies": "$shaderproxies",
                    "ukbuyproxies": "$ukbuyproxies",
                    "useacts": "$useacts",
                    "waithost": "$waithost",
                    "grouping": "$grouping",
                    "actId" : "$actId",
                    "actMemory" : "$actMemory"
                },
                suppliers: {
                    $push: {
                        name: "$name",
                        id: "$id"
                    }
                },
                count: {
                    $sum: 1
                }
            }
        }]).toArray((err, result) => {
            if (err) {
                console.log(err)
                next(err)
            } else {                

                let supplierActorList = []
                let supplierCrawlerList = []

                // I USED THIS TO CREATE TYHE GROUPING FILE MIGHT NOT NEED IT AGAIN BUT LEAVING ALSO NEED TO WRITE THE FILE BELOW
                // let grouping = {
                //     country: {
                //     }
                // }
                // grouping.country[country] = {}

                async.eachSeries(result, (one, done) => {

                    let stringId = JSON.stringify(one._id)
                    let id = md5(stringId)
                    let key = "APIFY:" + country + ":" + id
                    if (one._id.useacts === true) {
                        supplierActorList.push(key)
                    } else {
                        supplierCrawlerList.push(key)
                    }

                    let supplierIds = []
                    let supplierNames = []

                    one.suppliers.map((supplier) => {
                        supplierIds.push(supplier.id)
                        supplierNames.push(supplier.name)
                    })

                    // Using this to generate script to setup the grouping
                    // grouping.country[country][id] = {
                    //     1: one.suppliers
                    // }
                    
                    this.APIFYTYPES.setTypes(country, id, supplierIds, supplierNames, one._id)

                    done()

                }, (err) => {
                    // Write the file if you want the raw groupings
                    // fs.writeFileSync('./' + country + 'grouping.json', JSON.stringify(grouping))
                    
                    if (err) {
                        console.log(err)
                        next(err)
                    } else {
                        let actorKey = "APIFY:" + country + ":ACTOR"
                        let crawlerKey = "APIFY:" + country + ":CRAWLER"
                        this.redisHandle.del(actorKey, crawlerKey, () => {
                            this.redisHandle.rpush(actorKey, supplierActorList)
                            this.redisHandle.rpush(crawlerKey, supplierCrawlerList)
                            next()
                        })
                    }
                })
            }
        })

    }
}