const handle = require('./handle');
const createIdKey = require('../createIdKey');
const rejig = require('./rejig');
const async = require('async');
const splitArrIntoSmallerBits = require('../splitArrIntoSmallerBits');
const splitArrOriginal = require('../splitArrIntoSmallerBitsOriginal');
const bulk = require('../../model/bulk');
const mapping = require('./mapping');


class Base {
    constructor(config) {
        this.config = config;
        this.handle = null;
    }

    runSearch(query, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                query._source
                query.body.sort
                // query.body.query = {
                //     match_all: {}
                // }
                // query.body.query = {
                //     match: {
                //         type: "Progress"
                //     }
                // }
                
                console.log('query:', JSON.stringify(query, null, 2))
                db.search(query, (err, result) => {
                    next(err, result)
                })

            }
        })
    }

    createIndex(index, type, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                let body = {
                    mappings: {}
                };
                body.mappings[type.replace('Mapping', '')] = mapping[type];

                db.indices.create({
                    index: index,
                    body: body
                }, function (err) {
                    next(err);
                });
            }
        });
    }

    mgetNew(payload, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                var mgetPayload = {
                    index: payload.index,
                    type: payload.type,
                    body: {
                        ids: payload.ids
                    }
                };

                if (payload.fields) {
                    mgetPayload._source = payload.fields;
                }

                db.mget(mgetPayload, (err, result) => {
                    if (err) {
                        next(err);
                    } else {
                        next(null, this.restructureMget(result));
                    }
                });
            }
        });
    }

    barcodeIn(index, barcodes, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                let inPayload = {
                    index: index,
                    type: 'supplier',
                    body: {
                        size: barcodes.length,
                        query: {
                            terms: {
                                barcode: barcodes
                            }
                        }
                    }
                };


                db.search(inPayload, (err, data) => {
                    if (err) {
                        next(err);
                    } else {

                        let results = {};
                        if (data.hits && data.hits.total) {
                            data.hits.hits.map((thisResult) => {
                                results[thisResult._source.barcode] = thisResult._source;
                            });
                        }
                        next(null, results);
                    }
                });
            }
        });
    }

    mget(payload, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                var mgetPayload = {
                    index: index,
                    type: payload.type,
                    body: {
                        ids: payload.ids
                    }
                };

                if (payload.fields) {
                    mgetPayload._source = payload.fields;
                }

                db.mget(mgetPayload, (err, result) => {
                    if (err) {
                        next(err);
                    } else {
                        next(null, this.restructureMget(result));
                    }
                });
            }
        });
    }

    restructureMget(records) {
        var result = {
            found: {},
            missing: {}
        };
        records.docs.map((record) => {
            if (record.found) {
                result.found[record._id] = record;
            } else {
                result.missing[record._id] = record;
            }
        });
        return result;
    }

    /**
     * Allow a find to run with a size larger than the default 10 records
     * @param {*} body
     * @param {*} size
     * @param {*} next
     */
    findWithSize(body, size, next) {
        handle(this.config, (err, db) => {

            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                db.search({
                    index: index,
                    size: size,
                    body: body
                }, (err, result) => {
                    if (err) {
                        if (err.response) {
                            let aggsQuery = {};
                            try {
                                var response = JSON.parse(err.response);
                                if (response.error.root_cause[0].reason === 'No mapping found for [created] in order to sort on' ||
                                    response.error.root_cause[0].reason === 'no such index') {
                                    var nothing = this.config.createIdKey ? {} : [];
                                    aggsQuery = {
                                        total: 0,
                                        records: nothing,
                                        aggs: {
                                            suppliers: {
                                                records: {}
                                            },
                                            categories: {
                                                records: {}
                                            }
                                        }
                                    };
                                }
                            } catch (e) {
                                console.error(e);
                                err = e;
                            } finally {
                                next(err, aggsQuery);
                            }
                        } else {
                            next(err);
                        }
                    } else {
                        var records = this.restructureData(rejig(result.hits.hits));
                        if (this.config.createIdKey) {
                            records = createIdKey('id', records);
                        }
                        var endResult = {
                            total: result.hits.total,
                            records
                        };

                        if (result.aggregations) {
                            endResult.aggs = this.rejigAggs(result.aggregations);
                        }
                        next(null, endResult);
                    }
                });
            }
        });
    }

    findAggs(body, next) {
        handle(this.config, (err, db) => {

            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                db.search({
                    index: index,
                    body: body
                }, (err, result) => {
                    if (err) {
                        console.log('err: ', err);
                        if (err.response) {
                            let aggsQuery = {};
                            try {
                                var response = JSON.parse(err.response);
                                if (response.error.root_cause[0].reason === 'No mapping found for [created] in order to sort on' ||
                                    response.error.root_cause[0].reason === 'no such index') {
                                    //var nothing = this.config.createIdKey ? {} : [];
                                    aggsQuery = {
                                        total: 0,
                                        records: nothing,
                                        aggs: {}
                                    };
                                }
                            } catch (e) {
                                console.log(e);
                                err = e;
                            } finally {
                                next(err, aggsQuery);
                            }
                        } else {
                            next(err);
                        }
                    } else {
                        //console.log('results: ', result);
                        var records = result.aggregations;

                        if (this.config.createIdKey) {
                            records = createIdKey('id', records);
                        }
                        var endResult = {
                            total: result.hits.total,
                            aggs: records && records.last_day && records.last_day.amazonCategory ? this.rejigCategoryAggs(records.last_day.amazonCategory) : {}
                        };

                        next(null, endResult);
                    }
                });
            }
        });
    }

    find(body, next) {

        handle(this.config, (err, db) => {

            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                db.search({
                    index: index,
                    body: body
                }, (err, result) => {
                    if (err) {
                        if (err.response) {
                            let aggsQuery = {};
                            try {
                                var response = JSON.parse(err.response);
                                if (response.error.root_cause[0].reason === 'No mapping found for [created] in order to sort on' ||
                                    response.error.root_cause[0].reason === 'no such index') {
                                    var nothing = this.config.createIdKey ? {} : [];
                                    aggsQuery = {
                                        total: 0,
                                        records: nothing,
                                        aggs: {
                                            suppliers: {
                                                records: {}
                                            },
                                            categories: {
                                                records: {}
                                            }
                                        }
                                    };
                                }
                            } catch (e) {
                                console.log(e);
                                err = e;
                            } finally {
                                next(err, aggsQuery);
                            }
                        } else {
                            next(err);
                        }
                    } else {
                        var records = this.restructureData(rejig(result.hits.hits));
                        if (this.config.createIdKey) {
                            records = createIdKey('id', records);
                        }
                        var endResult = {
                            total: result.hits.total,
                            records
                        };

                        if (result.aggregations) {
                            endResult.aggs = this.rejigAggs(result.aggregations);
                        }
                        next(null, endResult);
                    }
                });
            }
        });
    }

    search(body, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                let p = {
                    index: index,
                    body: body                    
                }
                db.search(p, (err, result) => {
                    if(err !== undefined) {
                        next(err);
                    } else {
                        err = null;
                        next(err, rejig(result.hits.hits));
                    }
                });
            }
        });
    }


    findById(payload, next) {

        handle(this.config, (err, db) => {
            this.handle = db;
            if (err) {
                next(err);
            } else {
                var index = this.collection;
                db.get({
                    index: index,
                    type: payload.type,
                    id: payload.id
                }, (err, result) => {
                    if (err) {
                        if (err.status === 404) {
                            next('NOT_FOUND');
                        } else {
                            next(err);
                        }
                    } else {
                        var endResult = false;
                        if (result.found === true) {
                            endResult = result._source;
                        }

                        next(null, endResult);

                    }

                });
            }
        });
    }

    simpleFind(data, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                db.get({
                    index: data.index,
                    type: data.type,
                    id: data.id
                }, next);
            }
        });
    }

    simpleUpdate(data, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                db.update({
                    index: data.index,
                    type: data.type,
                    id: data.id,
                    body: {
                        doc: data.doc
                    }
                }, next);
            }
        });
    }

    bulkUpdate(data, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                /*
                Bulk update accepts an array of alternating command and data items.
                Data needs to provide _id, _index and _type to identify the correct index
                it also needs a collection of fields to update:

                data = {
                    _index: "opportunity-wishlist-mike-us",
                    fieldName: "brData",
                    rowData: [
                        {_id:"127839612786321", _type:"www.cow.com", "rowData": {"fieldname1":"fieldValue1", "fieldname2":"fieldValue2" } },
                        {_id:"342876876376733", _type:"www.cat.com", "rowData": {"fieldname1":"fieldValue1", "fieldname2":"fieldValue2" } }
                    ]
                }
                */

                let bulkData = [];
                data.rowData.map((thisItem) => {
                    let dataRow = {
                        'doc': {
                            'amazon': {}
                        }
                    };
                    let updateCommand = {
                        update: {
                            _index: data._index,
                            _id: thisItem._id,
                            _type: thisItem._type
                        }
                    };

                    /**
                     * Write a blank record
                     */
                    bulkData.push(updateCommand); // write an update command
                    dataRow.doc.amazon[data.fieldName] = {};
                    bulkData.push(dataRow); // write an empty object as a placeholder (to over-write anything that may already be there)

                    /**
                     * Write the actual record
                     */
                    bulkData.push(updateCommand); // write an update command
                    dataRow.doc.amazon[data.fieldName] = thisItem.rowData;
                    bulkData.push(dataRow); // write the object we want to store

                });
                db.bulk({
                    body: bulkData
                }, function (err, resp) {
                    if (err) {
                        console.error('Err:', err);
                    }
                    next(err, resp);
                });
            }
        });
    }

    bulkStart() {
        bulk.reset();
    }


    bulkRaw(payload, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                db.bulk({
                    body: payload
                }, (err, resp) => {
                    next(err, resp);
                });
            }
        })
    }

    /**
     * Create a bulk update array from an array of data passed in payload:
     * payload.data = [ {data: value}, {data: value} ]
     * payload.action = [create|update|delete|index]
     * each record in data must have a _type which equates to the domain or the payload should contain a "domain" value
     */
    bulkAdd(payload, next) {
        if (payload.data && payload.action) {
            this.bulkStart(); // Ensure the bulk array is empty
            payload.data.map((id) => {
                let prod = payload.data[id];
                //console.log('Add this row: ', thisRow);
                let idLine = {};
                let action = payload.action.toLowerCase();
                idLine[action] = prod.exportElasticSearchIndexAsObject();
                let dataRow = {};
                if (action === 'update') {
                    dataRow.doc = prod.export();
                } else {
                    dataRow = prod.export();
                }
                let bulkData = (action === 'delete') ? [idLine] : [idLine, dataRow];
                bulk.add(bulkData);
            });
            let bulkData = bulk.get();
            this.bulkSave(bulkData, next);
        } else {
            next();
        }
    }

    bulkAddItem(data, domain, next) {
        let error = null;
        var bulkInsert;
        try {
            var idLine = {
                index: {
                    _index: this.collection,
                    _type: domain.replace(/\./g, '-')
                }
            };
            bulkInsert = [idLine, data];
            bulk.add(bulkInsert);
        } catch (e) {
            console.error('ERROR: ', e);
            error = e;
        } finally {
            next(error, bulkInsert);
        }
    }

    bulkSaveOriginal(data, next) {
        this.bulkSave(data, next, true)
    }

    bulkSave(data, next, useOriginal) {
        //console.log('SAVE THIS: ', JSON.stringify(data, null, 2));
        handle(this.config, (err, db) => {
            this.handle = db;
            if (err) {
                next(err);
            } else {
                let allArray = [].concat(data);
                let splitArray;
                if (useOriginal) {
                    splitArray = splitArrOriginal(splitArrOriginal, 100);
                } else {
                    splitArray = splitArrIntoSmallerBits(allArray, 100);
                }

                let x = 1;
                let endResult = {
                    items: []
                };
                async.eachSeries(splitArray, (opps, done) => {
                    //console.log('save these opps: ', opps);
                    db.bulk({
                        body: opps
                    }, (err, result) => {
                        if (err) {
                            done(err);
                        } else {
                            // Uncomment this for a bit of DEBUG
                            // opps.map((opp, index) => {
                            // 	if(index % 2 == 0) {
                            // 		console.log('GET /' + opp.index._index + '/' +  opp.index._type + '/' +  opp.index._id)
                            // 	}
                            // })
                            setTimeout(() => {
                                x++;
                                if (err) {
                                    done(err);
                                } else {
                                    endResult.items = endResult.items.concat(result.items);
                                    done(err, result);
                                }

                            }, 1000);

                        }

                    });
                }, (err) => {
                    if (err) {
                        next(err);
                    } else {
                        next(err, endResult);
                    }

                });
            }
        });
    }

    findRaw(body, next) {
        handle(this.config, (err, db) => {
            this.handle = db;
            if (err) {
                next(err);
            } else {
                var index = this.collection;
                db.search({
                    index: index,
                    body: body
                }, (err, result) => {
                    if (err) {
                        next(err);
                    } else {

                        var endResult = {
                            total: result.hits.total,
                            records: result.hits.hits
                        };

                        next(null, endResult);
                    }
                });
            }
        });
    }

    pagination(payload, next) {
        var newPayload = Object.assign({
            from: payload.start ? payload.start : 0,
            size: payload.size ? payload.size : 10
        }, payload);

        delete newPayload.start;

        this.find(newPayload, (err, result) => {
            if (err) {
                next(err);
            } else {
                result.start = payload.from;
                result.size = payload.size;

                next(null, result);
            }
        });
    }

    restructureData(records) {
        return records;
    }

    rejigCategoryAggs(aggs) {
        var newAggs = {};

        aggs.buckets.map((thisBucket) => {
            newAggs[thisBucket.key] = {
                name: thisBucket.key,
                total: thisBucket.doc_count
            };
        });
        return newAggs;
    }

    rejigAggs(aggs) {

        var newAggs = {};

        Object.keys(aggs).map((agg) => {
            newAggs[agg] = {};
            newAggs[agg].name = agg;
            newAggs[agg].records = {};
            aggs[agg].buckets.map((bucket) => {
                newAggs[agg].records[bucket.key] = {};
                newAggs[agg].records[bucket.key].name = bucket.key;
                newAggs[agg].records[bucket.key].total = bucket.doc_count;
            });
        });

        return newAggs;
    }

    delOpp(payload, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                db.delete({
                    index: index,
                    type: payload.type,
                    id: payload.id
                }, function (err, response) {
                    next(err, response);
                });
            }
        });
    }

    save(payload, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;
                var savePayload = {
                    index: index,
                    type: payload.type,
                    body: payload.data
                };
                if (payload.id) {
                    savePayload.id = payload.id;
                }

                db.index(savePayload, function (err, response) {
                    if (err) {
                        next(err);
                    } else {
                        next(null, response);
                    }
                });
            }
        });
    }

    // close() {
    //     this.handle.close();
    // }

    deleteScroll(scrollId, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                this.handle = db;
                db.clearScroll({
                    scrollId: scrollId
                }, function (err, response) {
                    next(err, response);
                });
            }
        });
    }


    scrollPage(body, next) {
        handle(this.config, (err, db) => {
            if (err) {
                console.error('ES:Base:Error: ', err);
                next(err);
            } else {
                this.handle = db;
                var index = this.collection;

                let searchQuery = {
                    index: index,
                    size: body.size,
                    scroll: body.scroll,
                    body: body.query,
                }
                // Use type is we have type (for backwards compatibility)
                if (body.type) {
                    searchQuery.type = body.type;
                }

                if (body._sourceExclude) {
                    searchQuery._sourceExclude = body._sourceExclude
                }

                if (body._source) {
                    searchQuery._source = body._source
                }

                db.search(searchQuery, (err, results) => {
                    if (err) {
                        next(err);
                    } else {
                        console.log('raw_results:', results)
                        let restructure = {
                            data: this.restructureData(rejig(results.hits.hits)),
                            scroll_id: results._scroll_id,
                            totalRows: results.hits.total,
                            index: index,
                            query: searchQuery
                        };
                        // if (this.config.createIdKey) {
                        //     restructure.data = createIdKey('id', restructure.data);
                        // }
                        next(null, restructure);
                    }

                });
            }
        });
    }

    scrollNext(body, next) {
        handle(this.config, (err, db) => {
            if (err) {
                console.error('Error: ', err);
                next(err);
            } else {
                db.scroll({
                    scrollId: body.scroll_id,
                    scroll: body.scroll
                }, (err, results) => {
                    if (err) {
                        next(err);
                    } else {
                        let restructure = {
                            data: this.restructureData(rejig(results.hits.hits)),
                            //scroll_id: results._scroll_id,
                            totalRows: results.hits.total
                        };
                        if (this.config.createIdKey) {
                            restructure.data = createIdKey('id', restructure.data);
                        }
                        next(null, restructure);
                    }
                });
            }
        });
    }

    count(next) {
        handle(this.config, (err, db) => {
            if (err) {
                console.error('Error: ', err);
                next(err);
            } else {
                db.count(next);
            }
        });
    }

}

module.exports = Base;