const handle = require('../lib/mongo/handle');
const Base = require('../lib/mongo/base');
const mongodb = require('mongodb');
const request = require('superagent');

class Supplier extends Base {

    constructor(config, collection) {
        // console.log('Supplier:collection: ', collection);
        super(config, collection.country + 'suppliers');
        this.country = collection.country;
    }

    generateLookup(next) {
        this.find({}, (err, result) => {
            if (err) {
                next(err)
            } else {
                var end = {}

                Object.keys(result.records).map((key, index) => {
                    // end[index] = result.records[key].name
                    end[key] = {
                        name: result.records[key].name,
                        domain: result.records[key].domain
                    }
                    // var oneResult = result.records[key]
                    // // console.log(oneResult)
                    // var domain = result.records[key].domain

                    // if (oneResult) {
                    //     end[oneResult.domain] = oneResult.name
                    // }
                })
                next(err, end)
            }
        })
    }

    generateDomainLookup(next) {

        var payload = {
            fields: {
                domain: -1,

            }
        }

        this.find(payload, (err, result) => {
            if (err) {
                next(err)
            } else {
                //console.log('result: ', JSON.stringify(result, null, 2));
                let lookup = {};
                result.records.map((thisRecord) => {
                    if (!lookup.hasOwnProperty(thisRecord.domain)) {
                        lookup[thisRecord.domain] = thisRecord.id;
                    }
                });
                next(err, lookup);
            }
        });
    }

    isSkuSupplier(domain, next) {
        this.find({ domain: domain }, (err, data) => {
            if (err) {
                next(err);
            } else {
                let result = false;
                data.records.map((thisResult) => {
                    if (thisResult.sku) {
                        result = true;
                    }
                });
                next(null, result);
            }
        });
    }

    findAll(payload, next) {
        
        var final = {
            sort: {},
            fields: payload.fields
        }

        if(!payload.sortBy || payload.sortBy === "name") {
            payload.sortBy = "name"
            final.sort[payload.sortBy] = -1
        } else {
            final.sort[payload.sortBy] = -1
        }

        this.find(final, (err, result) => {
            next(err, result)
        })
    }

    findSupplier(payload, next) {

        this.findById(payload.id, (err, result) => {
            if (err) {
                next(err)
            } else {
                next(null, result)

                // ****Should Have All THe Descriptions for suppliers now ****//
                // if(result.description) {

                // } else {


                // var url = "https://api.embedly.com/1/extract?key=4324db19a4574b05a46cb1f36be0348b&url=" + result.domain

                // request.get(url)
                // .end((err, data) => {
                //     if(err) {
                //         next(err)
                //     } else {
                //         result = data.body
                //         next(null, result)
                //     }


                // })

                // }

            }

        })
    }

    findApifyHostConfig(supplierId, fields, next)  {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                let collection = db.collection(this.collection);
                collection.find({
                    _id: mongodb.ObjectID(supplierId)
                }, fields).toArray(next);
            }
        });
    }   

    findSelection(payload, next) {

        payload.fields = {
            name: 1,
            domain: 1,
            live: 1,
            active: 1,
            lastRun: 1,
            enabled: 1,
            barcoded: 1,
            error: 1,
            maintenanceStatus: 1,
            periodCoverage: 1,
            starred: 1
        }

        payload.sort = { name: 1 }

        // If there is an error we do not want to show the results
        payload.error = false

        this.find(payload, next)
    }

    findEnabled(next) {
        let payload = {
            enabled: true,
            fields: {
                name: 1,
                domain: 1
            }
        }
        this.find(payload, next)
    }

    findLive(next) {
        let payload = {
            live: true,
            fields: {
                name: 1,
                domain: 1
            }
        };

        this.find(payload, next);
    }

    setMaintenanceStatus(payload, next){
        this.update({
            query: { _id: mongodb.ObjectID(payload.supplierId) },
            update: {
                $set: {
                    maintenanceStatus: payload.status
                }
            }
        }, (err, result) => {
            next(err, result);
        })
    }

    setApifySettings(payload, next) {

        this.update({
            query: { _id: mongodb.ObjectID(payload.supplierId) },
            update: {
                $set: {
                    waithost: payload.settings.waithost,
                    lazyloading: payload.settings.lazyloading,
                    shaderproxies:  payload.settings.shaderproxies,
                    ukbuyproxies:  payload.settings.ukbuyproxies,
                    falsejqueryinject: payload.settings.falsejqueryinject,
                    anticaptchaactor: payload.settings.anticaptchaactor,
                    shader10proxies: payload.settings.shader10proxies,
                    clickhosts: payload.settings.clickhosts,
                    checkerblacklist: payload.settings.checkerblacklist,
                    useacts: payload.settings.useacts,
                }
            }
        }, (err, result) => {
            next(err, result);
        })
    }

    save(payload, next) {

        delete payload.lastRun;

        if (payload.error === false) {
            payload.note = ''
            payload.status = 'RESET'
        }

        this.update({
            query: { _id: mongodb.ObjectID(payload.id) },
            update: {
                $set: payload
            }
        }, (err, result) => {
            next(err, result)
        })
    }

    getRunning(next) {
        this.find({
            status: "IN_PROGRESS",
            sort: { name: 1 }
        }, (err, result) => {
            next(err, result)
        })
    }

    markCompleted(payload, next) {

        this.update({
            query: { _id: mongodb.ObjectID(payload.id) },
            update: {
                $set: {
                    status: "COMPLETED",
                    lastRun: new Date()
                }
            }
        }, (err, result) => {
            next(err, result)
        })
    }

    markAllCompleted(payload, next) {
        this.updateMany({
            query: {},
            update: {
                $set: {
                    status: "COMPLETED",
                    lastRun: new Date()
                }
            }
        }, (err, result) => {
            next(err, result)
        })
    }

    updateError(payload, next) {

        this.update({
            query: { _id: mongodb.ObjectID(payload.supplierId) },
            update: {
                $set: {
                    status: "ERROR",
                    error: true,
                    note: payload.errorMessage + ' ' + new Date().toISOString()
                }
            }
        }, (err, result) => {
            next(err, result)
        })
    }



    resetError(payload, next) {
        this.update({
            query: { _id: mongodb.ObjectID(payload.id) },
            update: {
                $set: {
                    status: "RESET",
                    error: false,
                    note: ''
                }
            }
        }, (err, result) => {
            next(err, result)
        })
    }

    makeSupplierLive(payload, next) {
        this.update({
            query: { _id: mongodb.ObjectID(payload.id) },
            update: {
                $set: {
                    live: true
                }
            }
        }, (err, result) => {
            next(err, result)
        })
    }

    addSupplier(payload, next) {
        var supplierpayload = {
            name: payload.name,
            domain: payload.domain
        };
        this.insert(supplierpayload, (err) => {
            next(err);
        });
    }

    deleteSupplier(payload, next) {
        this.delById(payload.id, next);
    }


    getScheduleDay(dayIndex, next) {
        let payload = {
            schedule: { $in: [dayIndex] },
            fields: ['name', 'lastRun', 'error', 'crawlerStart', 'enabled', 'status', 'totalUrls', 'live']
        }

        this.find(payload, (err, result) => {
            next(err, result)
        })
    }

    getPsScheduleDay(dayIndex, next) {
        let payload = {
            psSchedule: { $in: [dayIndex] },
            fields: ['name', 'lastRun', 'error', 'crawlerStart', 'enabled', 'status', 'totalUrls', 'live']
        }

        this.find(payload, (err, result) => {
            next(err, result)
        })
    }

    getScheduleCounts(next) {

        handle(this.config, (err, db) => {
            if (err) {
                next(err)
            } else {
                var collection = db.collection(this.collection)
                collection.aggregate([
                    { $unwind: "$schedule" },
                    { $group: { _id: '$schedule', count: { $sum: 1 } } },
                    { $project: { tmp: { day: '$_id', count: '$count' } } },
                    { $group: { _id: 'schedule', days: { $sum: 1 }, data: { $addToSet: '$tmp' } } }
                ], (err, result) => {
                    if (err) {
                        next(err)
                    } else {
                        let arrayResult = result.length > 0 ? result[0].data : result
                        let objResult = {}
                        arrayResult.map((dayCount) => {
                            objResult[dayCount.day] = dayCount.count
                        })

                        next(null, objResult)
                    }

                    db.close()
                })



                //  collection.aggregate([
                //         { $group: {
                //             _id: id,
                //             uniqueIds: { $addToSet: "$_id" },
                //             count: { $sum: 1 }
                //         } },
                //         { $match: {
                //             count: { $gte: 2 }
                //         } },
                //         { $sort : { count : -1} },
                //         { $limit : 10 }
                //         ], { allowDiskUse: true }, (err, result) => {
                //             next(err, result)
                //             db.close()
                //         });
            }
        })
    }

    getPsScheduleCounts(next) {

        handle(this.config, (err, db) => {
            if (err) {
                next(err)
            } else {
                var collection = db.collection(this.collection)
                collection.aggregate([
                    { $unwind: "$psSchedule" },
                    { $group: { _id: '$psSchedule', count: { $sum: 1 } } },
                    { $project: { tmp: { day: '$_id', count: '$count' } } },
                    { $group: { _id: 'psSchedule', days: { $sum: 1 }, data: { $addToSet: '$tmp' } } }
                ], (err, result) => {
                    if (err) {
                        next(err)
                    } else {
                        let arrayResult = result.length > 0 ? result[0].data : result
                        let objResult = {}
                        arrayResult.map((dayCount) => {
                            objResult[dayCount.day] = dayCount.count
                        })

                        next(null, objResult)
                    }

                    db.close()
                })
            }
        })
    }

    updatePeriodCoverage(payload, next) {
        handle(this.config, (err, db) => {
            var collection = db.collection(this.collection)
            collection.findAndModify({ _id: mongodb.ObjectID(payload.supplierId) },
            [],
             {
                $set: { periodCoverage: payload.periodCoverage }
            }, (err, modifiedJob) => {
                next(err, modifiedJob);
            })
        })
    }

}

module.exports = Supplier
