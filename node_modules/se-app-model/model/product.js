const Base = require('../lib/es/base');
const md5 = require('md5');
// const url = require('url');
const updateDelta = require('../lib/updateDelta');
const updateAmazonDelta = require('../lib/updateAmazonDelta');
const getDomain = require('../lib/getDomain');
const Bulk = require('./bulk');
const util = require('util');

const barcodeQuery = require('../esQueries/barcodeQuery');
const textMatchQuery = require('../esQueries/textMatchQuery');

const aggsCache = require('../lib/aggsCache');

class Product extends Base {

    constructor(config, country, supplier, index) {
        let amazonDomain = country === 'uk' ? 'uk-www-amazon-co-uk' : 'us-www-amazon-com';
        if(supplier) {
            amazonDomain = country + '-' + supplier
        }

        if(index) {
            amazonDomain = index
        }

        super(config, amazonDomain);
        this.country = country;
    }

    getProductsToEnumerate(payload, next) {
        // payload.type = payload.domain.replace(/\./g, '-');
        // payload.fields = ['state','asin','barcode', 'price', 'delta']
        this.mgetNew(payload, next);
    }

    getProductsToMatch(payload, next) {
        if (!payload[0].url) {
            next('NO_URL');
            return;
        }

        var domain = getDomain(payload[0].url);
        var mgetPayload = {
            ids: [],
            type: domain,
            fields: ['state', 'asin', 'barcode', 'updated']
        };

        payload.map((record) => {
            var id = md5(record.name);
            record.id = id;
            record.domain = domain;
            mgetPayload.ids.push(id);
        });

        this.mget(mgetPayload, next);
    }

    getProductsToMatchNew(index, type, ids, next) {
        var mgetPayload = {
            index,
            ids,
            type,
            fields: ['state', 'asin', 'barcode', 'updated', 'matchDistance', 'matchStatus','stateDeltaUser']
        };
        this.mgetNew(mgetPayload, next);
    }

    getBarcodeProductsToMatch(index, barcodes, next) {
        this.barcodeIn(index, barcodes, next);
    }

    bulkEnumerateSupplier(payload, record, next) {
        updateDelta(payload, record, (err, result) => {
            var idLine = {
                index: {
                    _index: this.collection,
                    _type: getDomain(record.url),
                    _id: md5(payload.name)
                }
            };
            var bulkInsert = [idLine, result];
            Bulk.add(bulkInsert);
            next(null, bulkInsert);
        });
    }

    findAmazon(payload, next) {
        this.collection = this.country === 'us' ? 'us-www-amazon-com' : 'uk-www-amazon-co-uk';
        this.findById({
            type: 'amazon',
            id: payload.id
        }, (err, result) => {
            if (err) {
                if (err.status === 404) {
                    next('NOT_FOUND');
                } else {
                    next(err);
                }
            } else {
                next(null, result);
            }

        });
    }

    getAmazonProducts(ids, next) {
        let mgetPayload = {
            index: this.country === 'us' ? 'us-www-amazon-com' : 'uk-www-amazon-co-uk',
            type: 'amazon',
            ids
        };

        this.mgetNew(mgetPayload, next);
    }

    saveAmazon(payload, next) {
        this.collection = this.country === 'us' ? 'us-www-amazon-com' : 'uk-www-amazon-co-uk',
            this.save({
                type: 'amazon',
                id: payload.id,
                data: payload.data
            }, (err, result) => {
                next(err, result);
            });
    }

    findAmazonMatch(payload, next) {
        this.findSupplier({
            domain: getDomain(payload.url),
            name: payload.name
        }, (err, result) => {
            if (err) {
                if (err === 'NOT_FOUND') {
                    next(null, {
                        state: 'NOT_FOUND'
                    });
                } else {
                    next(err);
                }
            } else {
                next(err, result);
            }

        });
    }

    findSupplier(payload, next) {
        this.findById({
            type: payload.domain.replace(/\./g, '-'),
            id: payload.id ? payload.id : md5(payload.name)
        }, (err, result) => {
            next(err, result);
        });
    }

    saveNotFoundSupplier(payload, next) {
        // ADD PRODUCT
        var now = new Date().toISOString();
        var esPayload = Object.assign({}, payload);

        esPayload.state = 'NEW';
        esPayload.created = now;
        esPayload.updated = now;
        esPayload.supplier = getDomain(payload.url);

        esPayload.delta = [{
            price: payload.price,
            timestamp: now
        }];

        // REMOVE STUFF WE DONT WANT TO SAVE IN THE DB
        delete esPayload.price;
        delete esPayload.id;
        delete esPayload.index;
        delete esPayload.type;
        delete esPayload.user;
        delete esPayload.userName;
        delete esPayload.fullUrlId;
        delete esPayload.country;
        delete esPayload.apiKey;
        delete esPayload.filter;
        delete esPayload.meta;

        this.saveSupplier({
            url: esPayload.url,
            name: esPayload.name,
            data: esPayload
        }, next);
    }

    saveSupplier(payload, next) {
        this.save({
            type: getDomain(payload.url),
            id: payload.id ? payload.id : md5(payload.name),
            data: payload.data
        }, (err, result) => {
            next(err, result);
        });
    }

    saveAmazonDelta(payload, next) {

        // GET ALL THE AMAZON RECORDS
        let index = this.country === 'us' ? 'us-www-amazon-com' : 'uk-www-amazon-co-uk'
        let mgetPayload = {
            index,
            type: 'amazon',
            ids: Object.keys(payload)
        };

        if (mgetPayload.ids.length === 0) {
            return next(null, 'NO_AMAZON_RECORDS_TO_UPDATE');
        }

        this.mgetNew(mgetPayload, (err, result) => {
            if (err) {
                next(err);
            } else {
                // UPDATE THE AMAZON RECORD
                var bulk = [];
                Object.keys(result.found).map((asin) => {
                    payload[asin].addExistingRecord(result.found[asin]._source)
                    var idLine = {
                        index: payload[asin].exportElasticSearchIndexAsBulkObject()
                    };
                    var bulkInsert = [idLine, payload[asin].export()];
                    bulk = bulk.concat(bulkInsert);
                });

                if (bulk.length > 0) {
                    this.bulkSave(bulk, (err, results) => {
                        next(err, results);
                    });
                } else {
                    next(null);
                }

            }
        });
    }

    bulkSaveProducts(products, next) {
        if (products.length === 0) {
            next('NO_PRODUCTS');
        } else {
            this.bulkSave(products, next);
        }
    }

    getProductsToMatchByType(payload, next) {
        let query = payload.type === 'barcode' ? barcodeQuery(payload) : textMatchQuery(payload);
        this.find(query, next);
    }

    /* getProductsWithBarcodesAndNoAsins(payload, next) {
        let query = {
            "sort": [
                {
                    "updated": {
                        "order": "asc"
                    }
                }
            ],
            "from": payload.from,
            "size": payload.size,
            "query": {
                "bool": {
                    "must": [
                        {
                            "exists": {
                                "field": "barcode"
                            }
                        },
                        {
                            "bool": {
                                "should": [
                                    {
                                        "bool": {
                                            "must_not": [
                                                {
                                                    "exists": {
                                                        "field": "asin"
                                                    }
                                                }
                                            ],
                                            "must": [
                                                {
                                                    "match": {
                                                        "state": "new"
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "bool": {
                                            "must": [
                                                {
                                                    "term": {
                                                        "state": "matched"
                                                    }
                                                },
                                                {
                                                    "exists": {
                                                        "field": "stringMatch"
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        };
        //console.log('query: ', util.inspect(query, true, 20));
        this.find(query, next);
    } */

    getAmazonCategories(payload, next) {

        // let query = {
        //     size: 0,
        //     aggs: {
        //         amazonCategory: {
        //             terms: { field: 'category' }
        //         }
        //     }
        // };

        // For this query to work the index should be a wildcard for all suppliers in this country area
        // excluding the amazon indexes
        this.collection = payload.country + '-*, -' + payload.country + '-www-amazon-' + (payload.country === 'uk' ? 'co-uk' : 'com') + ',-' + payload.country + '-stats*';
        let query = {
            "size": 0,
            "aggs": {
                "last_day": {
                    "filter": {
                        "range": {
                            "updated": {
                                "gte": "now-" + payload.categorySearchAge + "d/d"
                            }
                        }
                    },
                    "aggs": {
                        "amazonCategory": {
                            "terms": {
                                "field": "category.keyword"
                            }
                        },
                        "size":"500"
                    }
                }
            }
        };
        payload.query = query;
        payload.keyName = 'catAggs';
        aggsCache(this, payload, next);
    }

    scrollFirstAmazonCategory(payload, next) {
        let body = {
            _source: [ "asin","name", "price", "url", "image", "skuSupplier", "sku", "matchDistance", "barcode", "state", "stateDeltaUser" ],
            size: payload.size,
            scroll: payload.scroll,
            query: {
                query: {
                    bool: {
                        must: [
                            {
                                term: {
                                    category: payload.category
                                }
                            },
                            {
                                range: {
                                    updated: {
                                        gte: 'now-' + payload.categorySearchAge + 'd/d'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        };

        this.scrollPage(body, next);
    }

    nextScroll(payload, next) {
        let scrollId = payload.scroll_id || payload.scrollId || null;
        let body = { scroll: payload.scroll, scroll_id: scrollId };
        this.scrollNext(body, next);
    }

    removeScroll(payload, next) {
        let scrollId = payload.scroll_id || payload.scrollId || null;
        this.deleteScroll(scrollId, next);
    }

    getStats(next) {
        var query = {
            "size" : 0,
            "query": {
            "match_all" : {}
            },
            "aggs" : {
                "state" : {
                    "significant_text" : { "field" : "state" }
                },
                "matchStatus": {
                    "terms": {
                        "field": "matchStatus.keyword"
                    }
                }
            }
        };

        this.find(query, next);
    }

    /**
     * SMGLI-587 - Get Matching Records for ASINS or TEXT
     */
    getReverseSearchProducts(payload, next) {

        let a = payload.country + '-www-amazon-' + (payload.country === 'us' ? 'com' : 'co-uk');
        this.collection = payload.country + '-*,-' + a;
        let query = {
            "_source" : ['asin','name','price','state','country','url','matchDistance','barcode','updated','matchStatus','stateDeltaUser'],
            "query": {
              "bool": {
                "should": []
              }
           }
        }

        let field = payload.subType.toLowerCase() === 'asin' ? 'asin' : 'name';
        let esType = payload.subType.toLowerCase() === 'asin' ? 'term' : 'match';

        payload.data.map((value) => {
            let obj = {};
            obj[esType] = {};
            obj[esType][field] = value;
            query.query.bool.should.push(obj)
        })


        this.findRaw(query, (err, data) => {
            if(err) {
                next(err)
            } else {
                let result = [];
                data.records.map((record) => {
                    result.push(record._source)
                })
                next(null, result)
            }

        });

    }

}

module.exports = Product;
