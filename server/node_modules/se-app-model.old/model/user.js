const Base = require('../lib/mongo/base');
const mongodb = require('mongodb');
const secureRandom = require('secure-random');
const crypto = require('crypto');
const async = require('async')

var api = {
	"uk": {
		"AWSAccessKeyId": "AKIAJPMYVCKVZOVHIUVQ",
		"SecretKey": "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",
		"AmazonServicesURL": "mws-eu.amazonservices.com",
		"MarketPlaceId": "A1F83G8C2ARO7P"
	},
	"us": { // Original US values
		"AWSAccessKeyId": "AKIAJNEDWYSZQKOL5URA", /** OUR US DEV ACCOUNT (everything should be pointing here, these keys should be used everywhere for when we need to make calls )**/
		"SecretKey": "CuZxP3cOal1y2db3bu/JLfbMIVmvciQDqPexhTI8",
		"AmazonServicesURL": "mws.amazonservices.com",
		"MarketPlaceId": "ATVPDKIKX0DER"
	}
	// "us":{
	// 	"AWSAccessKeyId": "AKIAJ22GKMDHQFT45MLA", /** Adrian's account (we use the seller id and auth token for searches ) **/
	// 	"SecretKey": "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",
	// 	"AmazonServicesURL": "mws.amazonservices.com",
	// 	"MarketPlaceId": "ATVPDKIKX0DER"
	// }
}



class User extends Base {

	constructor(config) {
		super(config, 'users');
	}

	_validAffiliate(payload) {
		return payload && payload.agency && payload.affiliateCode && payload.trackingCode && payload.referrer && payload.status ? true : false;
	}

	setAffiliate(payload, next) {
		let affiliate = payload.affiliate;
		if (this._validAffiliate(affiliate)) {
			let updateUser = {
				query: { _id: mongodb.ObjectID(payload.userId) },
				update: { $set: { affiliate: affiliate } }
			};
			this.update(updateUser, next);
		} else {
			next('INVALID_AFFILIATE');
		}
	}

	setGDPRFlag(payload, next){
		let updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId)
			},
			update: {
				$set: {
					gdpr: true
				}
			}
		};
		this.update(updatePayload, next);
	}

	//Set an expiry date to prevent login when this date has passed
	setExpiryDate(payload, next) {
		let expiryDate = new Date(0);
		expiryDate.setUTCSeconds(payload.expiryDate); // expiry date is a raw epoch as it comes from Stripe
		let updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId)
			},
			update: {
				$set: {
					expiryDate: expiryDate,
					cancelledAt: new Date()
				}
			}
		};
		this.update(updatePayload, next);
	}

	setStripeSubscription(payload, next) {
		let status = null;
		if (payload.hasOwnProperty('stripeSubscription') && payload.stripeSubscription.hasOwnProperty('object') && payload.stripeSubscription.object.hasOwnProperty('status')) {
			status = payload.stripeSubscription.object.status;
		}
		let updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId)
			},
			update: {
				$set: {
					stripeSubscription: payload.stripeSubscription
				}
			}
		};
		// If the status has been passed down (trialing or active), store this at the top level to make querying easier
		if (status) {
			updatePayload.update.$set = {
				stripeSubscription: payload.stripeSubscription,
				stripeStatus: status
			};
		}
		this.update(updatePayload, next);
	}

	getReferralCount(payload, next) {
		let query = {
			"referral": { $exists: true },
			"referral.code": payload.referralCode,
			"referral.claimed": false,
			"stripeStatus": "active"
		};
		this.count(query, next);
	}

	setClaimedReferrals(payload, next) {
		let updateUser = {
			query: {
				"referral": { $exists: true },
				"referral.code": payload.referralCode,
				"referral.claimed": false,
				"stripeStatus": "active"
			},
			update: {
				$set: {
					"referral.claimed": true,
					"referral.claimedDate": new Date()
				}
			},
			flags: {
				"multi": true
			}
		};
		this.update(updateUser, (err) => {
			if (err) {
				next(err);
			} else {
				let updateReferrer = {
					query: {
						_id: mongodb.ObjectID(payload.userId)
					},
					update: {
						$set: { discountLastRun: new Date(new Date().getTime() + 172800000) } // 172800000 = number of milliseconds in 2 days
					}
				};
				this.update(updateReferrer, next);
			}

		});
	}

	getAllApiKeys(country, userIds, next) {
		let keys = [];
		let now = new Date();
		let query = {
			'apiStatus': true,
			'expiryDate': { $gte: now },
			'_id': {$nin: userIds}
		};
		query['api.' + country] = { $exists: true };

		this.find(query, (err, result) => { // only return keys where they're marked as valid
			if (err) {
				next(err);
			} else {
				result.records.map((thisResult) => {
					if (thisResult.api) {
						if (country === 'uk') {
							keys.push({ keys: thisResult.api.uk, id: thisResult.id, quota: thisResult.quota });
						} else {
							keys.push({ keys: thisResult.api.us, id: thisResult.id, quota: thisResult.quota });
						}
					}
				});
				next(null, keys);
			}
		});
	}

	updateQuota(payload, next) {
		let updateUser = {
			query: {
				_id: mongodb.ObjectID(payload.id)
			},
			update: {
				$set: {
					quota: {
					}
				}
			}
		};
		updateUser.update.$set.quota[payload.country] = {};
		updateUser.update.$set.quota[payload.country][payload.type] = {
			availableDate: payload.nextDate
		};
		this.update(updateUser, next);
	}

	getApiKey(payload, next) {


		this.findById(payload.userId, (err, result) => {
			if (err) {
				next(err)
			} else {
				var userKey = result.api[payload.country];

				if (userKey === undefined) {
					next(null, false)
				} else {
					var userApiKey = {
						"SellerId": userKey.sellerId,
						"MWSAuthToken": userKey.authToken,
					}

					var apiKey = Object.assign(api[payload.country], userApiKey);
					next(null, apiKey)
				}
			}

		})

	}

	saveApiKeys(payload, next) {

		var update = {
			api: {},
			expiredKeys: false
		}

		if (payload.signUpCountry) {
			var country = payload.signUpCountry
			update.api[country] = {
				sellerId: payload.sellerId,
				authToken: payload.authToken
			}

			var updatePayload = {
				query: {
					_id: mongodb.ObjectID(payload.userId),
				},
				update: {

					$set: update

				}
			}

			this.update(updatePayload, next)
		} else if (payload.availableCountry.length === 2) {

			var country1 = payload.availableCountry[0]
			var country2 = payload.availableCountry[1]
			var keysToGet = country1

			var supplierIdKeep
			var authTokenKeep

			if (country1 === payload.country) {
				keysToGet = country2
			}

			async.waterfall([
				(done) => {

					this.findById(payload.userId, (err, result) => {
						if (err) {
							console.log(err)
						} else {

							supplierIdKeep = result.api[keysToGet].sellerId
							authTokenKeep = result.api[keysToGet].authToken
							done(null)
						}
					})
				},
				(done) => {

					update.api[payload.country] = {
						sellerId: payload.sellerId,
						authToken: payload.authToken
					}

					update.api[keysToGet] = {
						sellerId: supplierIdKeep,
						authToken: authTokenKeep
					}
					done(null)
				}
			], (err) => {
				if (err) {
					console.log(err)
				} else {

					var updatePayload = {
						query: {
							_id: mongodb.ObjectID(payload.userId),
						},
						update: {

							$set: update

						}
					}

					this.update(updatePayload, next)
				}
			})
		} else {
			console.log("100")
			var country

			if (payload.signUpCountry) {
				country = payload.signUpCountry
			} else {
				country = payload.country
			}

			update.api[country] = {
				sellerId: payload.sellerId,
				authToken: payload.authToken
			}

			var updatePayload = {
				query: {
					_id: mongodb.ObjectID(payload.userId),
				},
				update: {

					$set: update

				}
			}

			this.update(updatePayload, next)
		}
	}

	findUserByName(username, next) {
		this.findOne({
			username,
			expiryDate: {
				$gte: new Date()
			}
		}, (err, result) => {
			next(err, result)
		})
	}

	findUserByEmail(email, next) {
		this.findOne({
			email
		}, (err, result) => {
			next(err, result)
		})
	}

	findByStripeCustomerId(id, next) {
		this.findOne({
			stripeId: id
		}, next);
	}

	findUserById(id, next) {
		this.findById(id, (err, result) => {
			next(err, result)
		})
	}

	findUserByToken(token, next) {
		this.findOne({
			'resetToken.token': token
		}, next);
	}


	checkExistingSellerId(payload, next) {

		if (payload.country === 'uk') {
			this.findOne({
				'api.uk.sellerId': payload.sellerId
			}, (err, result) => {
				next(err, result)
			})
		} else {
			this.findOne({
				'api.us.sellerId': payload.sellerId
			}, (err, result) => {
				next(err, result)
			})
		}
	}

	findBrandRestrictionsInfo(message, next) {

		this.findById(message.userId, (err, data) => {
			let countryCode = message.country === 'ie' ? 'uk' : message.country;
			let result = {
				merchantId: data.api[countryCode].sellerId,
				AWSAccessKeyId: api[countryCode].AWSAccessKeyId,
				MWSAuthToken: data.api[countryCode].authToken,
				secretKey: api[countryCode].SecretKey,
				emailAddress: data.email,
				userName: data.username,
				userId: data.id
			}
			next(null, result);
		});

	};

	checkPassword(email, password, next) {

		this.findUserByEmail(email, (err, result) => {
			if (err) {
				next(err)
			} else {
				if (result) {
					const payloadHashed = crypto.createHmac('sha256', result.salt)
						.update(password)
						.digest('hex');

					if (payloadHashed !== result.password) {
						next('INCORRECT_PASSWORD', false)
					} else {
						let now = new Date()
						let expire = new Date(result.expiryDate)
						if (now > expire) {
							next('ACCOUNT_EXPIRED')
						} else {
							next(null, result)
						}
					}
				} else {
					next('USER_NOT_FOUND')
				}
			}
		})
	}

	delResetToken(payload, next) {
		var updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId),
			},
			update: {
				$set: {
					'resetToken.token': ''
				}
			}
		}
		this.update(updatePayload, next)
	}

	addResetToken(payload, next) {
		var updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId),
			},
			update: {

				$set: {
					resetToken: {
						token: payload.token,
						timestamp: payload.timestamp
					}
				}

			}
		}
		this.update(updatePayload, next)
	}

	savePassword(payload, next) {

		// TODO: First check if password is valid, return error if current password is not correct

		var salt = _generateSalt()
		var passwordHash = _generatePassword(payload.password, salt)

		var passwordChange = {
			salt: salt,
			password: passwordHash
		}


		var updatePayload = {
			query: {
				_id: new mongodb.ObjectID(payload.userId),
			},
			update: {

				$set: passwordChange

			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})

	}

	getAllUsers(payload, next) {
		this.find(payload, next)
	}

	setReferralCode(payload, next) {
		// update all the records identified by payload.ids to show their referral has been credited
		var updatePayload = {
			query: {
				_id: mongodb.ObjectID(payload.userId),
			},
			update: {
				$set: {
					referralCode: payload.referralCode
				}

			}
		}
		this.update(updatePayload, next)
	}

	checkIfReferralCodeExists(referralCode, next) {
		if (!referralCode) {
			next(null);
		} else {
			this.find({ referralCode: referralCode }, (err, user) => {
				if (err || !user) {
					next('INVALID_REFERRALCODE');
				} else {
					next(null, user);
				}
			});
		}
	}


	checkIfInfoExists(payload, next) {
		var username = payload.username.toLowerCase()
		var email = payload.email.toLowerCase()
		var states = {
			username: '',
			email: ''
		}

		async.waterfall([
			(done) => {
				this.findOne({
					username
				}, (err, result) => {
					if (err) {
						console.log(err)
					} else if (result === null) {
						states.username = ''
						done(null)
					} else {
						states.username = 'USERNAME_EXISTS'
						done(null)
					}
				})
			},
			(done) => {
				this.findOne({
					email
				}, (err, result) => {
					if (err) {
						console.log(err)
					} else if (result === null) {
						states.email = ''
						done(null)
					} else {
						states.email = 'EMAIL_EXISTS'
						done(null)
					}
				})
			}
		], (err) => {
			next(err, states)
		})
	}

	/**
	 * Given a userId return the global filters
	 * @param {*} payload
	 * @param {*} next
	 */
	getGlobalFilters(payload, next) {
		this.findById(payload.userId, (err, results) => {
			if (err) {
				logger.error(err)
				next(err);
			} else {

				if (results && results.globalFilters && results.globalFilters.addFbaCharges !== 'off') {
					results.globalFilters.fbaCharges = true
				} else {
					results.globalFilters.fbaCharges = false;
				}
				if (results && results.globalFilters && results.globalFilters.addVat !== 'on') {
					results.globalFilters.addVat = false;
				} else {
					results.globalFilters.addVat = true;
				}

				results.globalFilters.shippingFee = payload.options && payload.options.shippingFee ? parseInt(payload.options.shippingFee) : 0;
				results.globalFilters.coupon = payload.options && payload.options.coupon ? parseInt(payload.options.coupon) : 0;

				next(null, results.globalFilters);
			}
		});
	}

	saveGlobalFilters(payload, next) {
		var filters = {
			globalFilters: {}
		}

		filters.globalFilters = {
			addFbaCharges: payload.addFbaCharges,
			nominalFbaCharge: payload.nominalFbaCharge,
			addVat: payload.addVat,
			otherCosts: payload.otherCosts,
			coupon: payload.coupon,
			shippingFee: payload.shippingFee,
			fullfilmentFeesPerItem: payload.fullfilmentFeesPerItem,
			cashBackAmount: payload.cashBackAmount,
			toolTipsOff: payload.toolTipsOff,
			deleteSearchesOlderThan: payload.deleteSearchesOlderThan
		}

		var updatePayload = {
			query: {
				_id: new mongodb.ObjectID(payload.userId),
			},
			update: {

				$set: filters

			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	updateSentEmails(payload, next) {
		var updatePayload = {
			query: {
				_id: new mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: { sentEmails: payload.sentEmails }
			}
		}
		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	updateApiStatus(payload, next) {
		var updatePayload = {
			query: {
				_id: new mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: { apiStatus: payload.status }
			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	updateFirstTime(payload, next) {
		var updatePayload = {
			query: {
				_id: new mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: { firstTime: payload.firstTime }
			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}




	registerUser(payload, next) {
		let username = payload.username
		let email = payload.email.toLowerCase()

		this.findOne({
			username
		}, (err, result) => {
			if (err) {
				console.log(err)
			} else if (result === null) {
				this.findOne({
					email
				}, (err, result) => {
					if (err) {
						console.log(err)
					} else if (result === null) {

						/** Generate salt and password Hash **/

						/** LowerCase everything **/
						var name = payload.name.toLowerCase();
						var salt = _generateSalt()
						var passwordHash = _generatePassword(payload.password, salt)

						var userInfo = {
							created: new Date(),
							name: name,
							username: username,
							password: passwordHash,
							salt: salt,
							email: email,
							lastFour: payload.lastFour,
							plan: payload.plan,
							subscriptionEnd: payload.subscriptionEnd,
							stripeId: payload.stripeId,
							gdpr: payload.gdpr,
							api: {
								uk: {
									sellerId: null,
									authToken: null
								},
								us: {
									sellerId: null,
									authToken: null
								}
							},
							apiStatus: false,
							firstTime: true,
							country: payload.country,
							expiryDate: payload.expiryDate,
							offerCode: payload.offerCode,
							invoices: [],
							globalFilters: {
								addFbaCharges: "on",
								nominalFbaCharge: 5,
								addVat: "off",
								otherCosts: 0,
								coupon: 0,
								shippingFee: 0,
								fullfilmentFeesPerItem: 0,
								cashBackAmount: 0,
								toolTipsOff: 'off'
							},
							referralCode: payload.referralCode,
							referral: payload.referral,
							planCode: payload.planCode,
							affiliateCode: payload.affiliateCode,
							readNewSearchInfo: true
						}

						/** insert data into database **/

						this.insert(userInfo, (err) => {
							next(err)
						})

					} else {
						next("EMAIL_EXISTS")
					}
				})

			} else {
				next("USERNAME_EXISTS")
			}


		})
	}

	updateLastFour(payload, next) {
		var newLastFour = {
			lastFour: payload.lastFour
		}

		var updatePayload = {
			query: {
				_id: new mongodb.ObjectID(payload.userId),
			},
			update: {
				$set: newLastFour
			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	returningCustomer(userId, next) {
		var updatePayload = {
			query: {
				_id:  mongodb.ObjectID(userId)
			},
			update: {
				$set: {
					returningCustomer: true
				}
			}
		}

		this.update(updatePayload,next)
	}

	setUserFeedBackPriority(message, next) {

		var updatePayload = {
			query: {
				_id: mongodb.ObjectId(message.customerId)
			},
			update: {
				$set: {
					feedBackMessagePriority: message.priority
				}
			}
		}

		this.update(updatePayload, next)
	}

	updateSubscriptionEnd(payload, next) {
		var newSubscriptionEndDate = {
			subscriptionEnd: payload.subscriptionEnd
		}

		var updatePayload = {
			query: {
				_id: new mongodb.ObjectID(payload.userId),
			},
			update: {
				$set: newSubscriptionEndDate
			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	addInvoices(payload, next) {
		var invoices = {
			invoices: payload.invoices
		}

		var updatePayload = {
			query: {
				_id: new mongodb.ObjectId(payload.userId),
			},

			update: {
				$set: invoices
			}
		}

		this.update(updatePayload, (err) => {
			next(err)
		})
	}

	getValidUsers(payload, next) {
		this.find(payload, next)
	}

	getCancelledUsers(payload, next) {
		let now = new Date()
		now.setDate(now.getDate() - 30)

		this.find({
			fields: ['email', 'stripeId', 'country', 'plan'],
			$and: [{"stripeSubscription.object.cancel_at_period_end": true}, {"expiryDate" : { $lte : now }}]
		}, next)
	}

	claimedFreeTrial(payload, next) {
		let updatePayload = {
			query: {
				_id: mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: {
					freeTrialClaimed: true
				}
			}
		}

		this.update(updatePayload, next);
	}

	expiredKeys(payload, next) {

		var update = {
			api: {},
			expiredKeys: true
		}

		update.api[payload.country] = {
			sellerId: "",
			authToken: ""
		}

		let updatePayload = {
			query: {
				_id: mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: update
			}
		}

		console.log(JSON.stringify(updatePayload, null, 2))

		this.update(updatePayload, next);
	}

	saveFilterPresets(payload, next) {

		this.findById(payload.userId, (err, result) => {
			if(err) {
				console.log(err)
			} else {

				if(result.filterPresets) {

					var update = {
						filterPresets: {}
					}

					Object.keys(result.filterPresets).map((key) => {
						update.filterPresets[key] = result.filterPresets[key]
					})

					if(payload.deleteFilter) {
						delete update.filterPresets[payload.filterName]
						update.selectedFilterPreset = "noPreset"
					} else {
						update.filterPresets[payload.filterName] = payload.filters
					}



				} else {
					var update = {
						filterPresets: {}
					}

					update.filterPresets[payload.filterName] = payload.filters
				}

				let updatePayload = {
					query: {
						_id: mongodb.ObjectId(payload.userId)
					},
					update: {
						$set: update
					}
				}

				this.update(updatePayload, next);
			}
		})
	}

	saveSelectedFilterPreset(payload, next) {
		var update = {
			selectedFilterPreset: payload.filterName
		}

		let updatePayload = {
			query: {
				_id: mongodb.ObjectId(payload.userId)
			},
			update: {
				$set: update
			}
		}

		this.update(updatePayload, next);
	}

}

const _generateSalt = () => {
	var randomHash = secureRandom.randomArray(10).join(Math.random());
	var salt = crypto.createHmac('sha256', randomHash).digest('hex');
	return salt
}

const _generatePassword = (password, salt) => {
	return crypto.createHmac('sha256', salt).update(password).digest('hex');
}

module.exports = User

