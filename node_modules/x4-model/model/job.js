const handle = require('../lib/mongo/handle')
const Base = require('../lib/mongo/base')
const splitArrIntoSmallerBits = require('../lib/splitArrIntoSmallerBits')
const SearchModel = require('./search.js')
const async = require('async')
const mongodb = require('mongodb')
const url = require('url')
const saveJobReversePayload = require('../lib/saveJobReversePayload');
const saveJobCategoryPayload = require('../lib/saveJobCategoryPayload');

class Job extends Base {

    constructor(config) {
        super(config, 'job')
    }


    findJobById(id, next) {
        this.findById(id, (err, result) => {
            next(err, result)
        })
    }

    findAllJobsWithUserId(userId, next) {
        var query = {
            userId: String(userId)
        }
        this.find(query, (err, result) => {
            next(err, result)
        })
    }

    save(payload, next) {

        if (payload.urls.length === 0) {
            next('NO_URLS')
            return
        }

        var urls = payload.urls
        var maxUrls = payload.maxUrls ? payload.maxUrls : 20;
        delete payload.urls
        delete payload.maxUrls

        payload.totalUrls = urls.length;
        payload.status = "QUEUED";
        payload.created = new Date();
        payload.jobs = null;   // We set this later
        payload.stats = defaultStats;
        payload.domain = url.parse(urls[0].url).host
        payload.analysed = 0
        payload.categories = []

        async.waterfall([
            (done) => {
                this.insert(payload, (err) => {
                    if (err) {
                        done(err);
                    } else {
                        payload.jobId = payload._id.toString();
                        done(null);
                    }
                })
            },
            (done) => {

                var searchesToCreate = [];

                if (payload.totalUrls > maxUrls) {
                    searchesToCreate = splitArrIntoSmallerBits(urls, maxUrls);
                } else {
                    searchesToCreate.push(urls);
                }

                var n = 0;
                var searchIds = {}
                var Search = new SearchModel(this.config)

                async.eachSeries(searchesToCreate, function (u, end) {

                    var first = (n * maxUrls) + 1;
                    var last = (first + u.length) - 1;

                    Search.save({
                        name: payload.name + '_' + first + '_TO_' + last,
                        supplier: payload.name,
                        urls: u,
                        suppliers: payload.suppliers,
                        searchSettings: payload.searchSettings,
                        filter: payload.filter,
                        country: payload.country,
                        userName: payload.userName,
                        userId: payload.userId,
                        jobId: payload.jobId
                    }, function (err, response) {
                        searchIds[response.searchId] = {
                            searchId: response.searchId,
                            status: "QUEUED"
                        };
                        n++;
                        end(err);

                    })

                }, (err) => {
                    done(err, searchIds)
                })
            },
            (searchIds, done) => {
                payload.jobs = searchIds
                this.update({
                    query: {
                        _id: mongodb.ObjectID(payload.jobId)
                    },
                    update: {
                        $set: { jobs: searchIds }
                    }
                }, (err) => {
                    done(err)
                })
            }
        ], (err) => {
            next(err, payload)
        })

    }

    findOlderThanXDays(payload, next) {

        var d = new Date();
        d.setDate(d.getDate() - payload.noOfDays);

        this.find({
            userId: String(payload.userId),
            created: { $lt: d },
            country: payload.country,
            fields: ['created', 'name', 'created'],
            sort: { 'created': 1 }
        }, (err, result) => {
            if (err) {
                next(err)
            } else {
                console.log(result)
                next(null, result.records)
            }
        })

    }

    /**
     * Save a non-URL job
     *
     * @param {any} payload
     * @param {any} next
     * @memberof Job
     */
    saveJob(payload, next) {
        console.log('Save Job');
        payload.status = 'QUEUED';
        payload.created = new Date();
        /**
         * Determine the name depending on job type
         */
        let fileNameParts = (payload.fileName + '').split('/') || false;
        let fileName = fileNameParts ? fileNameParts[fileNameParts.length - 1] : 'Uploaded File';
        switch (payload.jobType) {
            case 'URL':
                payload.name = payload.type;
                break;
            case 'CATEGORYSEARCH':
                payload.name = payload.originalCategory;
                break;
            case 'CSV':
                payload.name = fileName;
                break;
        }

        this.insert(payload, (err, newJob) => {
            //console.log('newJob: ', newJob);
            payload.jobId = payload._id;
            delete payload._id;
            next(err, payload)
        });
    }

    saveReverseSearch(payload, next) {
        this._saveCommonJob(saveJobReversePayload(payload), (err, newJob) => {
            if(err) {
                next(err)
            } else {
               next(null, newJob) ;
            }
        });
    }

    saveCategorySearch(payload, next) {
        console.log(payload)
        this._saveCommonJob(saveJobCategoryPayload(payload), (err, newJob) => {
            if(err) {
                next(err)
            } else {
               next(null, newJob) ;
            }
        });
    }

    _saveCommonJob(payload, next) {
       this.insert(payload, (err, newJob) => {            
            payload.jobId = payload._id;
            delete payload._id;
            next(err, payload)
        });
    }

    delById(id, next) {
        handle(this.config, (err, db) => {
            var collection = db.collection(this.collection)
            collection.findAndModify({ _id: mongodb.ObjectID(id) }, {}, { remove: true }, (err, deletedJob) => {
                if (err) {
                    next(err)
                } else {
                    var Search = new SearchModel(this.config)
                    Search.remove({
                        jobId: id
                    }, (err, result) => {
                        if (err) {
                            next(err)
                        } else {
                            next(null, deletedJob.value)
                        }
                    })
                }

            })
        })
    }

    checkRunning(payload, next) {
        this.find({
            userId: String(payload.userId),
            status: "IN_PROGRESS",
            country: payload.country
        }, (err, result) => {
            if (err) {
                next(err)
            } else {
                next(null, result.records)
            }
        })

    }

    rescanJob(payload, next) {

        delete payload._id;
        payload.name = payload.name.replace(' RESCAN', '') + ' RESCAN';
        payload.status = "QUEUED"

        Object.keys(payload.jobs).map(function (key) {
            payload.jobs[key].status = "QUEUED";
            delete payload.jobs[key].store
        })

        payload.stats = defaultStats;
        payload.created = new Date()
        payload.port = '';

        this.insert(payload, (err) => {
            if (err) {
                next(err)
            } else {
                payload.jobId = payload._id.toString();
                delete payload._id;
                next(null, payload)
            }
        })

    }
    /*
        saveCsv(payload, next) {

            payload.type = 'CSV';
            payload.totalUrls = 0;
            payload.status = "QUEUED";
            payload.created = new Date();
            payload.domain = payload.domain
            payload.analysed = 0
            payload.categories = []

            console.log('mongo:jobs:saving: ', payload);

            this.insert(payload, (err) => {
                payload.jobId = payload._id.toString();
                delete payload._id
                next(err, payload)
            })

        } */

    searchFinished(payload, next) {

        var searchId = payload.searchId;
        var jobId = payload.store.jobId;

        this.findById(jobId, (err, result) => {

            if (err) {
                next(err)
            } else {
                if (result === null) {
                    next('NO RESULT FOR ID ' + jobId)
                } else {
                    var selectedJob = result;

                    var queued = 0;
                    var searchAnalysed = 0

                    Object.keys(selectedJob.jobs).map(function (searchKey) {

                        if (searchKey === searchId) {
                            selectedJob.jobs[searchKey].status = "COMPLETED"
                            selectedJob.jobs[searchKey].store = payload.store;
                            // This was the old way when we counted all the different states
                            // searchAnalysed = _productsAnalysed(payload.store.productCount)
                            searchAnalysed = payload.store.productsFound

                            if (payload.markAsCompleted !== true) {
                                // THERE WAS A PROBLEM SO DON'T TRY AND ADD UP THE STATS
                                JOB_TOTAL_STATS(selectedJob.stats, payload.store);
                            }

                        }

                        if (selectedJob.jobs[searchKey].status === "QUEUED") {
                            queued++
                        }
                    })

                    if (searchAnalysed === undefined) {
                        searchAnalysed = 0
                    }
                    selectedJob.analysed += searchAnalysed

                    if (queued === 0) {
                        selectedJob.status = "COMPLETED"
                    }

                    if (queued === 0) {
                        selectedJob.status = "COMPLETED"
                    }

                    if (payload.markAsCompleted === true) {
                        selectedJob.status = "ERROR"
                    }

                    this.update({
                        "query": {
                            _id: mongodb.ObjectID(jobId)
                        },
                        "update": selectedJob
                    }, (err) => {
                        next(null, queued);
                    })

                }
            }

        })

    }

    run(payload, next) {
        // console.log('job: run', payload);

        this.findById(payload.jobId, (err, result) => {
            //   console.log('found job err:', err, '   result: ', result);
            if (err) {
                next(err);
            } else {
                if (result === null) {
                    next('NO RESULT FOR ID ' + payload.jobId)
                } else {
                    var jobInfo = result;
                    jobInfo.port = payload.port;

                    var jobToRun = false;

                    if (jobInfo.jobs && jobInfo.jobs !== null) {
                        for (let j of Object.keys(jobInfo.jobs)) {
                            if (jobInfo.jobs[j].status === "QUEUED") {
                                jobToRun = jobInfo.jobs[j];
                                break;
                            }
                        }
                    } else {
                        console.log('NO SEARCHES FOR ' + payload.jobId)
                    }

                    // Handle non URL jobs
                    if (jobInfo.jobType) {
                        jobToRun = payload;
                        jobInfo.status = "IN_PROGRESS";
                    } else if (jobToRun !== false && jobToRun !== 'false') {
                        jobInfo.jobs[jobToRun.searchId].status = "IN_PROGRESS"
                        jobInfo.status = "IN_PROGRESS";
                    }

                    this.update({
                        query: { _id: mongodb.ObjectID(payload.jobId) },
                        update: jobInfo
                    }, (err) => {
                        if (jobToRun !== false && jobToRun !== 'false') {
                            jobToRun.jobId = payload.jobId;
                            jobToRun.country = jobInfo.country;
                            jobToRun.port = jobInfo.port;
                            jobToRun.name = jobInfo.name;
                            jobToRun.userName = jobInfo.userName;
                            jobToRun.created = jobInfo.created;
                        }
                        next(err, jobToRun);
                    })

                }

            }

        })

    }

    getQueuedJobs(next) {
        this.find({ status: 'QUEUED', fields: { userId: 1, userName: 1, country: 1 }, sort: { created: 1 } }, (err, result) => {
            next(err, result)
        })
    }

    getUserQueuedJobs(payload, next) {

        console.log('job model getUserQueuedJobs queue :', JSON.stringify({ userId: payload.userId, country: payload.country, status: 'QUEUED' }))

        this.find({ userId: payload.userId, country: payload.country, status: 'QUEUED', fields: { userId: 1, userName: 1, country: 1, jobType: 1, name: 1 }, sort: { created: 1 } }, (err, result) => {
            if (err) {
                next(err)
            } else {
                console.log('job model getUserQueuedJobs result:', JSON.stringify(result))
                if (result.total === 0) {
                    next('NO_QUEUED', result)
                } else {
                    next(null, result)
                }
            }
        })
    }

    lastRun(payload, next) {
        // db.job.find({}, {name: 1, created: 1, userName: 1}).sort({created: 1 })

        this.find({
            query: {},
            sort: { created: - 1 },
            fields: { name: 1, created: 1 }
        }, (err, result) => {
            next(err, result)
        })
    }

    setInProgress(jobId, next) {
        this._setStatus("IN_PROGRESS", jobId, next)
    }

    setError(jobId, next) {
        this._setStatus("ERROR", jobId, next)
    }

    setComplete(jobId, next) {
        this._setStatus("COMPLETE", jobId, next)
    }

    _setStatus(status, jobId, next) {
        this.update({
            query: {
                _id: mongodb.ObjectID(jobId)
            },
            update: {
                //$set: { status: status, analysed: payload.analysed }
                $set: { status: status }
            }
        }, (err) => {
            next(err);
        });
    }

    /**
     * Mark a job as "COMPLETE"
     * @param {*} payload
     * @param {*} next
     */
    completeJob(payload, next) {
        this.update({
            query: {
                _id: mongodb.ObjectID(payload.jobId)
            },
            update: {
                $set: { status: "COMPLETE", analysed: payload.analysed }
            }
        }, (err) => {
            next(err);
        });
    }

    /**
    * Mark a job as "STALLED"
    * @param {*} payload
    * @param {*} next
    */
    markJobAsStalled(payload, next) {
        this.update({
            query: {
                _id: mongodb.ObjectID(payload.jobId)
            },
            update: {
                $set: { status: "STALLED", analysed: payload.analysed }
            }
        }, (err) => {
            next(err);
        });
    }

}

const _productsAnalysed = (products) => {
    var total = 0

    if (products) {
        Object.keys(products).map((key) => {
            total += products[key].count
        })
    }

    return total
}

const JOB_TOTAL_STATS = function (defaultStore, savedStore) {

    if (!savedStore.error && savedStore.type !== 'CRAWLER') {
        // Removing all the stats as we are nbot using them at the moment anymore, could add them back for admin user
        // defaultStore.queues.PRODUCT_ENUMERATOR.totalsent = savedStore.queues.PRODUCT_ENUMERATOR.totalsent;
        // defaultStore.queues.GET_COMPETITIVE_PRICE_FOR_ASIN.totalsent = savedStore.queues.GET_COMPETITIVE_PRICE_FOR_ASIN.totalsent;
        // defaultStore.queues.CALCULATE_FEES.totalsent = savedStore.queues.CALCULATE_FEES.totalsent;
        // defaultStore.queues.GET_LOWEST_OFFER_LISTINGS_FOR_ASIN.totalsent = savedStore.queues.GET_LOWEST_OFFER_LISTINGS_FOR_ASIN.totalsent;

        // defaultStore.productCount.NEW.count = savedStore.productCount.NEW.count;
        // defaultStore.productCount.MATCHED.count = savedStore.productCount.MATCHED.count;
        // defaultStore.productCount.PROCESSING.count = savedStore.productCount.PROCESSING.count;
        // defaultStore.productCount.NOASIN.count = savedStore.productCount.NOASIN.count;
        // defaultStore.productCount.OUTSIDE_THRESHOLD.count = savedStore.productCount.OUTSIDE_THRESHOLD.count;
    }

}

const defaultStats = {
    queues: {
        PRODUCT_ENUMERATOR: {
            totalsent: 0
        },
        GET_COMPETITIVE_PRICE_FOR_ASIN: {
            totalsent: 0
        },
        CALCULATE_FEES: {
            totalsent: 0
        },
        GET_LOWEST_OFFER_LISTINGS_FOR_ASIN: {
            totalsent: 0
        }
    },
    productCount: {
        NEW: { count: 0 },
        MATCHED: { count: 0 },
        PROCESSING: { count: 0 },
        NOASIN: { count: 0 },
        OUTSIDE_THRESHOLD: { count: 0 }
    }
}

module.exports = Job
