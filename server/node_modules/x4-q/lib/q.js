const q = require('./redis')
const makeSafe = require('./makeSafe')


module.exports = class Q {

    constructor(config, qName) {
        this.config = config;
        this.qname = makeSafe(qName)
        this.mq = q.mq(config, this.qname)

        this.rsmqOptions = Object.assign({
            maxsize: -1   // Default is to now not have a max size
        }, config.rmsqOptions);

        config.options = config.options ? config.options : {}
        this.options = Object.assign({
            maxWait: 4000,
            interval: 1
        }, config.options)

        this.workerProcess = null
    }

    send(type, message, next) {

        this.mq.createQueue({qname: this.qname, maxsize: this.rsmqOptions.maxsize}, (err, resp) => {

            if(err !== null && err.toString() === 'queueExists: Queue exists') {
                this._send(type, message, next)
            } else if(err === null) {
                console.log(new Date(), "CREATE Q:", this.qname);
                this._send(type, message, next)
            } else {
                next(err)
            }
        });

    }

    _send(type, message, next) {
        let msg = {
            type: type,
            data : message
        }       

        if(msg.debug) {
            console.log(new Date().toISOString() + ' [' + this.qname + '] -> [' + msg.type + '] ' + Object.keys(msg.data))
        }
        
        this.mq.sendMessage({qname: this.qname, message: JSON.stringify(msg)}, (err, resp) => {
            if(err) {
                console.error(this.qname + ' ' + err.toString())
            }
            next(err, resp)
        });
    }

    _runWorker(mq, qname, options, _runWorker, onMessage, timeout) {

        if(timeout > options.maxWait) {
            timeout = options.interval
        } 


        setTimeout(() => {            

            timeout = timeout * 2
            mq.popMessage({qname: qname}, function (err, resp) {

                if(err) {
                    if(err.toString() !== 'queueNotFound: Queue not found') {
                        onMessage(err)
                    } else {
                        // If we don't have a q then just keep running until 1 arrives
                        _runWorker(mq, qname, options, _runWorker, onMessage, timeout)
                    }
                } else {
                    if (resp.id) {
                        let msg  = JSON.parse(resp.message);
                        if(msg.debug) {
                            console.log(new Date().toISOString() +' [' + qname + '] <- [' + msg.type + '] ' + Object.keys(msg.data))
                        }
                        onMessage(null, msg, () => {
                            _runWorker(mq, qname, options, _runWorker, onMessage, options.interval)
                        })
                    }
                    else {
                        _runWorker(mq, qname, options, _runWorker, onMessage, timeout)
                    }
                }


            });

        }, timeout)

    }

    worker(onMessage, next)  {
        let _runWorker = this._runWorker
        let options = this.options
        this._runWorker(this.mq, this.qname, options, _runWorker, onMessage, this.options.interval)
        next();
    }


    delete(cb) {
        this.mq.deleteQueue({qname: this.qname}, (err, resp) => {
            cb(err, resp)
        });
    }

    getN(n, cb) {
        let finished = n;
        let messages = [];
        let qname = this.qname
        let pop = (mq, qname, cb) => {
            mq.popMessage({qname: qname}, function (err, resp) {

                if(err) {
                    if(err.toString() !== 'queueNotFound: Queue not found') {
                        cb(err)
                    } else {
                        // If we don't have a q then ignore
                        cb(null)
                    }
                } else {
                    if(resp.message) {
                        let msg  = JSON.parse(resp.message);
                        if(msg.debug) {
                            console.log(new Date().toISOString() +' [' + qname + '] <- [' + msg.type + '] ' + Object.keys(msg.data))
                        }
                        
                        cb(null, msg)
                    } else {
                        cb(null, 'NO_MESSAGE')
                    }

                }
            })
        }

        for(let x=0;x < n; x++) {

            pop(this.mq, qname, (err, msg) => {
                if(msg === 'NO_MESSAGE') {
                    finished--
                    if(finished === 0) {
                        cb(null, messages)
                    }
                } else {
                    finished--
                    messages.push(msg)
                    if(finished === 0) {
                        cb(null, messages)
                    }
                }
            })

        }
    }

    stats(cb) {
        this.mq.getQueueAttributes({ qname: this.qname }, function(err, info) {
            cb(err, info);
        })
    }

    quit() {
        q.clear(this.config, this.qname, () => {
            this.mq.quit();
        });
        
    }


}
