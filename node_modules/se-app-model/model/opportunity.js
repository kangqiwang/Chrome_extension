const Base = require('../lib/es/base');
const handle = require('../lib/es/handle');
const async = require('async');

//const Bulk = require('./bulk')
//const getDomain = require('../lib/getDomain');
const buildFilterQuery = require('../lib/buildFilterQuery');
//const md5 = require('md5');
//const splitArrIntoSmallerBits = require('../lib/splitArrIntoSmallerBits');
//const util = require('util');

const _buildIndex = (collection) => {
	var index = ['opportunity'];
	if (collection.wishlist) {
		index.push('wishlist');
	}
	if (collection.missmatch) {
		index = ['mismatch'];
		index.push('opportunity');
	}
	if (collection.buylist) {
		index.push('buylist')
	}
	if (collection.distribute) {
		index.push('distribute')
	} else {
		index.push(collection.userName);
	}
	index.push(collection.country);
	return index.join('-');
};

class Opportunity extends Base {
	constructor(config, collection) {
		super(config, _buildIndex(collection));
		this.country = collection.country;
	}

	findFilteredNoPaging(payload, next) {
		payload.pathname = '/wishlist';
		let query = buildFilterQuery(payload, this.config.version);
		delete query.aggs;
		payload.query = query;
		let allRecords = [];
		// Custom scroll to repeatedly read until all records are available
		// console.log('this.collection: ', this.collection);
		// console.log('query: ', JSON.stringify(query, null, 2));
		handle(this.config, (err, db) => {
			db.search({
				index: this.collection,
				type: 'opportunity',
				scroll: '30s',
				size: 10000,
				body: query
			}, function getMoreUntilDone(err, response) {
				if (err) {
					next(err);
				} else {
					//console.log('got ', allRecords.length, ' of ', response.hits.total);
					console.log('CSV: adding ', response.hits.hits.length, ' items');
					response.hits.hits.forEach(function (hit) {
						allRecords.push({
							supplier: hit._source.supplier,
							amazon: hit._source.amazon
						});
					});

					if (response.hits.total !== allRecords.length) {
						db.scroll({
							scrollId: response._scroll_id,
							scroll: '10s'
						}, getMoreUntilDone);
					} else {
						//console.log('all done', allRecords.length);
						next(null, allRecords);
					}
				}
			});
		});

	}

	findFiltered(payload, next) {
		var query = buildFilterQuery(payload, this.config.version);
		query.size = payload.size !== undefined ? payload.size : 10;
		query.from = payload.start !== undefined ? payload.start : 0;
		this.paginationWithoutDuplicates(query, next);
	}

	/**
	 * Find all opportunities for a user where the stock status is null
	 * @param {*} payload
	 * @param {*} next
	 */
	findItemsToUpdateStock(payload, next) {
		let body = {
			"sort": [{
				"supplier.productCheckDate": {
					"order": "desc"
				}
			}],
			query: {
				bool: {
					must: [{
						range: {
							'supplier.productCheckDate': {
								lte: 'now-' + payload.stockCheckAgeInDays + 'd/d'
							}
						}
					}]
				}
			}
		};
		this.findWithSize(body, 0, (err, data) => {
			if (err) {
				next(err)
			} else {
				this.findWithSize(body, data.total, (err, result) => {
					if (err) {
						next(err)
					} else {
						next(null, result)
					}
				});
			}
		});
	}

	findFilteredAsins(payload, next) {

		payload = Object.assign({
			size: 100,
			start: 0
		}, payload);

		let query = {
			query: {
				bool: {
					must: []
				}
			}
		};

		query.size = payload.size;
		query.from = payload.start;

		let thisQuery = payload.query || {
			'amazon.brandRestrictionResults.resultCode': 'unchecked'
		};
		if (!payload.noFilter) {
			query.query.bool.must.push({
				match: thisQuery
			}); // Only return items that haven't been checked for brand restrictions
		}
		//console.log('query: ', JSON.stringify(query, null, 2));
		this.find(query, (err, results) => {
			if (err) {
				next(err);
			} else {
				let result = {
					total: 0,
					records: []
				};
				// console.log('results: ',util.inspect(results, { showHidden: false, depth: null }))
				if (results && results.records) {
					let records = [];
					results = Object.keys(results.records).map((thisKey) => {
						let thisItem = results.records[thisKey];
						records.push({
							'asin': thisItem.amazon.asin,
							'_id': thisItem.id,
							'_type': thisItem.supplier.domain.replace(/\./g, '-')
						});
					});
					result = {
						total: results.length,
						records: records
					};
				}
				next(null, result);
			}
		});
	}

	deleteRestrictedAsins(payload, next) {

		payload.size = payload.size ? payload.size : 10
		payload.lastTotal = payload.lastTotal ? payload.lastTotal : 0

		let query = {
			size: payload.size,
			query: {
				bool: {
					must: [{
						"match": {
							"amazon.brandRestrictionResults.resultCode": "Error"
						}
					}]
				}
			}
		};

		let that = this

		this.find(query, (err, results) => {
			if (err) {
				next(err);
			} else {
				// console.log('results: ',util.inspect(results, { showHidden: false, depth: null }))

				if (results.total === 0) {
					next(null, 'No Products To Delete')
				} else if (results && results.records) {
					let recordsLeft = results.total - payload.size
					let oppsToDelete = [];
					results.records.map((thisOpportunity) => {
						oppsToDelete.push({
							"delete": {
								_index: this.collection,
								_type: 'opportunity',
								_id: thisOpportunity.id
							}
						})
						//oppsToDelete.push({ exportElasticSearchIndexAsObject: () => { return { _index: this.collection, _type: 'opportunity', _id: thisOpportunity.id }; } });
					});
					that.bulkRaw(oppsToDelete, (err, result) => {
						if (err) {
							next(err)
						} else {
							if (recordsLeft <= 0) {
								next(null, results.total + payload.lastTotal)
							} else {
								setTimeout(() => {
									payload.size = recordsLeft
									payload.lastTotal = results.total
									that.deleteRestrictedAsins(payload, next)
								}, 1000)

							}
						}

					});

				}
			}

		});
	}

	createUserIndex(type, next) {
		var index = this.collection;
		this.createIndex(index, 'opportunityMapping', () => {

			var splitOpp = index.split('-');
			splitOpp.splice(1, 0, 'wishlist');
			index = splitOpp.join('-');

			this.createIndex(index, 'opportunityMapping', () => {
				var missmatchIndex = this.collection
				var missMatchSplitOpp = missmatchIndex.split('-')

				missMatchSplitOpp.splice(1, 0, 'missmatch');
				missmatchIndex = missMatchSplitOpp.join('-');
				console.log(index)
				this.createIndex(missmatchIndex, 'missMatch', next);
			});

		});
	}

	createResultsIndex(next) {
		var index = this.collection;
		this.createIndex(index, 'opportunityMapping', next);
	}

	createMissMatchIndex(payload, next) {

		this.createIndex(payload.indexStructure, 'missMatch', next);
	}

	delUserIndex(index, next) {
		handle(this.config, (err, db) => {

			if (err) {
				next(err);
			} else {
				db.indices.delete({
					index: index,
				}, function (err) {
					if (err) {
						next(err);
					} else {
						next(null, true);
					}

				});

			}

		});

	}

	findAmazonCategories(jobId, next) {
		var query = {
			size: 0,
			query: {
				match: {
					jobId: jobId
				}
			},
			aggs: {
				category: {
					terms: {
						field: 'category'
					}
				}
			}
		};
		this.find(query, next);
	}

	addToWishList(opp, payload, next) {
		var type = 'opportunity';
		async.waterfall([
			(done) => {
				// Save the Opportunity in the Wishlist
				opp.created = new Date().toISOString();
				opp.productChecks.stock = 'CHECKING';

				opp.stockCheck = {
					lastUpdated: new Date('1970-01-01').toISOString()
				};
				this.saveWishList({
					userName: payload.userName,
					country: payload.country,
					type: type,
					id: payload.id,
					body: opp
				}, (err, result) => {
					done(err, result);
				});
			},
			(result, done) => {
				// Delete Opportunity
				this.delOpp({
					id: payload.id,
					type: type
				}, (err) => {
					done(err);
				});
			}
		], (err) => {
			if (err && err.status == 404) {
				next(null)
			} else {
				next(err);
			}

		});

	}

	saveWishList(payload, next) {

		handle(this.config, (err, db) => {

			if (err) {
				next(err);
			} else {
				var index = 'opportunity-wishlist-' + payload.userName + '-' + payload.country;
				db.index({
					index: index,
					type: payload.type,
					id: payload.id,
					body: payload.body
				}, (err, result) => {
					if (err) {
						next(err);
					} else {
						next(null, result);
					}
				});
			}
		});

	}

	addToBuyList(payload, next) {
		var type = 'opportunity';
		async.waterfall([
			(done) => {
				// Get the Opportunity

				this.findById({
					id: payload.id,
					type: type
				}, done);
			},
			(opp, done) => {
				// Save the Opportunity in the Buylist
				opp.created = new Date().toISOString();

				this.saveBuyList({
					userName: payload.userName,
					country: payload.country,
					type: type,
					id: payload.id,
					body: opp
				}, (err, result) => {
					done(err, result);
				});
			},
			(result, done) => {
				// Delete Opportunity
				this.delOpp({
					id: payload.id,
					type: type
				}, (err) => {
					done(err);
				});
			}
		], (err) => {
			next(err);
		});

	}

	addToDistribute(payload, next) {
		var type = 'opportunity';
		async.waterfall([
			(done) => {
				// Get the Opportunity

				this.findById({
					id: payload.id,
					type: type
				}, done);
			},
			(opp, done) => {
				// Save the Opportunity in the Buylist
				opp.created = new Date().toISOString();

				this.saveDistribute({
					userName: payload.userName,
					country: payload.country,
					type: type,
					id: payload.id,
					body: opp
				}, (err, result) => {
					done(err, result);
				});
			}
		], (err) => {
			next(err);
		});

	}

	saveBuyList(payload, next) {

		handle(this.config, (err, db) => {

			if (err) {
				next(err);
			} else {
				var index = 'opportunity-buylist-' + payload.userName + '-' + payload.country;
				db.index({
					index: index,
					type: payload.type,
					id: payload.id,
					body: payload.body
				}, (err, result) => {
					if (err) {
						next(err);
					} else {
						next(null, result);
					}
				});
			}
		});
	}

	saveDistribute(payload, next) {
		handle(this.config, (err, db) => {

			if (err) {
				next(err);
			} else {
				var index = 'opportunity-distribute-' + payload.country;
				db.index({
					index: index,
					type: payload.type,
					id: payload.id,
					body: payload.body
				}, (err, result) => {
					if (err) {
						next(err);
					} else {
						next(null, result);
					}
				});
			}
		});
	}


	findAllUserMatched(payload, next) {
		this.collection = 'mismatch-opportunity-*' + '-' + payload.country

		var body = {
			"size": 500,
			"query": {
				"bool": {
					"must": [{
						"match": {
							asin: payload.asin
						}
					}]
				}
			}
		}

		this.findRaw(body, next)

	}

	findInGlobalMisMatch(payload, next) {
		this.collection = "opportunity-globalusermissmatch-*"

		var body = {
			"size": 500,
			"query": {
				"bool": {
					"must": [{
						"match": {
							"amazon.asin": payload.asin
						}
					}]
				}
			}
		}

		this.findRaw(body, next)
	}

	findUserMatched(payload, next) {
		this.collection = 'mismatch-opportunity-' + payload.userName + '-' + payload.country

		var body = {
			"size": 500,
			"query": {
				"match_all": {}
			}
		}

		this.findRaw(body, next)

	}

	delUserMatchedOpps(payload, next) {
		this.collection = payload.index

		this.delOpp((payload), (err, result) => {
			if (err) {
				next(err)
			} else {
				next(null)
			}
		})


	}


	fixWishListForBrandRestrictions(payload, next) {
		var p = {
			query: {
				bool: {
					must_not: [{
						exists: {
							field: 'amazon.brandRestrictionResults'
						}
					}]
				}
			}
		};


		p.size = payload.size;


		this.find(p, (err, result) => {
			if (err) {
				next(err);
			} else {
				console.log(result.total);
				var bulk = [];
				result.records.map((record) => {
					// Default brand restrictions data is added to the record so we can just rin this
					let type = record.supplier.domain.replace(/\./g, '-');
					bulk.push({
						update: {
							_index: this.collection,
							_type: type,
							_id: record.id
						}
					});
					bulk.push({
						doc: {
							amazon: {
								brandRestrictionResults: record.amazon.brandRestrictionResults
							}
						}
					});
				});

				this.bulkSave(bulk, (err, result) => {
					next(err, result);
				});

			}
		});

	}

	/**
	 * payload = {stock: true|false, id: opportunityId}
	 */
	setStockStatus(payload, next) {
		handle(this.config, (err, db) => {
			if (err) {
				next(err);
			} else {
				db.update({
					index: this.collection,
					type: 'opportunity',
					id: payload.id,
					body: {
						doc: {
							productChecks: {
								stock: payload.stock
							}
						}
					}
				}, next);
			}
		});
	}

	delJob(id, next) {

		var query = {
			size: 100,
			query: {
				match: {
					jobId: id
				}
			},
			stored_fields: []
		};

		// if (this.config.version === 5.5) {
		// 	delete query.fields;
		// 	query.stored_fields = [];
		// }

		handle(this.config, (err, db) => {

			if (err) {
				next(err);
			} else {
				this.handle = db;
				var index = this.collection;
				db.search({
					index: index,
					body: query
				}, (err, searchResult) => {
					if (err) {
						next(err);
					} else {
						var deletePayload = [];
						searchResult.hits.hits.map((record) => {
							deletePayload.push({
								delete: {
									_index: record._index,
									_type: record._type,
									_id: record._id
								}
							});
						});

						if (deletePayload.length > 0) {
							db.bulk({
								body: deletePayload
							}, (err, result) => {
								if (err) {
									next(err);
								} else {
									if (searchResult.hits.total > searchResult.hits.hits.length) {
										// We still have more to delete, timeout gives ES time delete

										this.delJob(id, next);


									} else {
										next(err, result);
									}
								}

							});
						} else {
							next(null, 'NO_OPPORUNITIES_TO_DELETE');
						}


					}
				});
			}
		});

	}

	bulkSaveOpportunity(opportunities, domain, next) {
		this.bulkAdd({
			action: 'insert',
			data: opportunities,
			domain: domain
		}, next);
		// try {
		// 	var idLine = {
		// 		index: {
		// 			_index: this.collection,
		// 			_type: domain.replace(/\./g, '-')
		// 		}
		// 	}
		// 	var bulkInsert = [idLine, opportunity]
		// 	Bulk.add(bulkInsert)
		// 	next(null, bulkInsert)
		// } catch (e) {
		// 	console.log('ERROR')
		// 	next(e)
		// }

	}

	saveOpportunities(opportunities, next) {

		if (opportunities.length === 0) {
			next('NO_OPPORTUNITIES');
		} else {

			this.bulkSave(opportunities, next);

			/* handle(this.config, (err, db) => {

				if (err) {
					next(err);
				} else {
					let allArray = [].concat(opportunities);
					let splitArray = splitArrIntoSmallerBits(allArray, 100);
					let x = 1;
					let endResult = {
						items: []
					};
					async.eachSeries(splitArray, (opps, done) => {

						db.bulk({
							body: opps
						}, (err, result) => {
							if (err) {
								console.log(err);
								done(err);
							} else {
								// Uncomment this for a bit of DEBUG
								// opportunities.map((opp, index) => {
								// 	if(index % 2 == 0) {
								// 		console.log('GET /' + opp.index._index + '/' +  opp.index._type + '/' +  opp.index._id)
								// 	}
								// })
								setTimeout(() => {
									x++;
									if (err) {
										done(err);
									} else {
										endResult.items = endResult.items.concat(result.items)
									}

									done(err, result);
								}, 500);

							}

						});
					}, (err, results) => {
						if (err) {
							next(err);
						} else {
							next(err, endResult);
						}

					});

				}
			}); */

		}

	}

}



module.exports = Opportunity;