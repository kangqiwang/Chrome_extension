const Base = require('../lib/mongo/base');
const handle = require('../lib/mongo/handle');
const md5 = require('md5');
const mongodb = require('mongodb');

class Url extends Base {

    constructor(config) {
        super(config, 'urls');
    }


    getUrlData(payload, next) {
        var ids = [];
        payload.map((url) => {
            ids.push(md5(url));
        });

        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                var collection = db.collection(this.collection);

                collection.find({
                    urlId: {
                        $in: ids
                    }
                }, {
                    data: 1
                }).toArray((err, result) => {
                    if (err) {
                        next(err);
                    } else {
                        var data = [];

                        result.map((d) => {
                            if (d.data && d.data.records) {
                                data = data.concat(d.data.records);
                            }
                        });
                        next(err, data);
                    }
                    db.close();
                });
            }
        });
    }

    getUrlExpired(payload, next) {
        var ids = [];
        payload.map((url) => {
            ids.push(md5(url));
        });

        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                var collection = db.collection(this.collection);

                var MS_PER_MINUTE = 60000;
                var now = new Date();
                var aDayAgo = new Date(now - 1444 * MS_PER_MINUTE)

                collection.find({
                    urlId: {
                        $in: ids
                    },
                    lastRun: {
                        $lte: aDayAgo
                    }
                }, {
                    url: 1,
                    _id: -1
                }).toArray((err, result) => {
                    if (err) {
                        next(err);
                    } else {
                        let expiredUrls = []
                        result.map((d) => {
                            expiredUrls.push(d.url)
                        })
                        next(err, expiredUrls);
                    }
                    db.close();
                });
            }
        });
    }


    bulkSaveUrlData(urls, next) {
        handle(this.config, (err, db) => {
            if (err) {
                next(err);
            } else {
                var collection = db.collection(this.collection);
                var bulk = collection.initializeUnorderedBulkOp();
                var lastRun = new Date();
                let recordsToSave = 0;

                Object.keys(urls).map((id) => {
                    let Url = urls[id]

                    // Implements: SMGLI-839
                    // Change records to an empty array, but add total 
                    var set = {
                        lastRun: lastRun,
                        data: {
                            timestamp: lastRun,
                            records:  [],
                            recordsTotal: 0
                        }
                    };

                    if (Url.ok()) {
                        set.data.recordsTotal = Url.data() ? Url.data().length : 0;
                    } else {  
                        if(Url.error() == "404") {
                            set.status = "HTTP_404"
                        }
                    } 

                    // NOTE: Unique Key is urlId plus supplierId - However this qiery will update all urls
                    //       It is actually better to do things this way ast he data will be fresher for
                    //       the other urls
                    bulk.find({
                        urlId: Url.id()
                    }).update({
                        $set: set
                    });
                    recordsToSave++;
                
                });

                if (recordsToSave === 0) {
                    next('NO_DATA_TO_SAVE');
                    db.close();
                } else {
                    bulk.execute((err, result) => {
                        if (err) {
                            next(err);
                        } else {
                            next(null, result);
                        }
                        db.close();
                    });
                }

            }
        });
    }

    findStats(payload, next) {
        let newPayload = {
            supplierId: payload.supplierId,
        };
        let totals = {
            allUrls: 0,
            runSinceMidnight: 0
        };
        this.findData(newPayload, (err, data) => {
            if (err) {
                next(err);
            } else {
                totals.allUrls = data.total;
                this.findValid(newPayload, (err, data) => {
                    if (err) {
                        next(err);
                    } else {
                        totals.runSinceMidnight = totals.allUrls - data.total;
                        next(err, totals);
                    }
                });
            }
        });
    }

    findValid(payload, next) {
        
        const ignoreLastRun = payload.ignoreLastRun;
        delete payload.ignoreLastRun;

        var newPayload = Object.assign(payload, {
            $or: [{
                status: 'SEARCH_PAGE'
            }, {
                status: 'NEW'
            }, {
                status: 'NEVER'
            }, {
                status: 'UNKNOWN'
            }]
        });

        // Just get all the URLS for now do not worry when we last checked them
        let start = new Date();
        start.setUTCHours(0, 0, 0, 0);

        // let timestamp = Math.round(new Date().getTime() / 1000);
        // var timestampYesterday = timestamp - 86400;

        // //  { $lt: timestampYesterday } to get urls not in run in last 24 hours rather than since midnight

        
        if(!ignoreLastRun) {
            // FIND URLS THAT HAVE NOT BEEN RUN IN THE LAST 48 HOURS
            let lastRunDate = new Date()
            lastRunDate.setDate(lastRunDate.getDate() - 1)

            newPayload.lastRun = {
                $lt: new Date(lastRunDate)
            }
        } 
    
        newPayload.sort = {
            lastRun: 1
        };

        this.find(newPayload, (err, result) => {
            next(err, result);
        });
    }

    findOneValid(payload, next) {
        var newPayload = Object.assign(payload, {
            $or: [{ status: 'SEARCH_PAGE' }, { status: 'NEW' }]
        });

        let start = new Date();
        start.setUTCHours(0, 0, 0, 0);

        let timestamp = Math.round(new Date().getTime() / 1000);
        var timestampYesterday = timestamp - 86400;

        //  { $lt: timestampYesterday } to get urls not in run in last 24 hours rather than since midnight
        newPayload.lastRun = { $lt: new Date(start) }

        newPayload.sort = { lastRun: 1 };

        console.log(newPayload)

        this.find(newPayload, (err, result) => {
            next(err, result);
        });
    }


    findData(payload, next) {
        /* var newPayload = Object.assign(payload, {
            data: { $exists: true }
        }); */

        this.find(payload, (err, result) => {
            next(err, result);
        });
    }

    findOldBySupplier(payload, next) {
        this.find({
            supplierId: payload.supplierId,
            lastRun: {
                $lt: new Date(payload.lastDate)
            }
        }, next);
    }

    findByUrl(payload, next) {
        this.find({
            urlId: md5(payload.url)
        }, (err, result) => {
            if (err) {
                next(err);
            } else {
                if (result.records.length === 1) {
                    next(null, result.records[0]);
                } else {
                    next(null, 'URL_NOT_FOUND');
                }
            }
        });
    }

    saveData(payload, next) {
        var key = md5(payload.url);
        var now = new Date();

        this.update({
            query: {
                urlId: key
            },
            update: {
                $set: {
                    data: {
                        lastRun: now,
                        records: payload.data
                    }
                }
            }
        }, (err) => {
            if (err) {
                next(err);
            } else {
                next(null, true);
            }
        });
    }

    updateSupplierId(payload, next) {
        var supplierId = payload.supplierId;

        var updateField = {
            supplierId: supplierId
        };

        var updatePayload = {
            query: {
                _id: mongodb.ObjectID(payload.id),
            },
            update: {

                $set: updateField

            }
        };

        this.update(updatePayload, (err) => {
            next(err);
        });
    }


    updateStatus(payload, next) {
        var status = payload.status;

        var updateField = {
            status: status
        };

        var updatePayload = {
            query: {
                _id: mongodb.ObjectID(payload.id),
            },
            update: {

                $set: updateField

            }
        };

        this.update(updatePayload, (err) => {
            next(err);
        });
    }

    updateStructureHtmlUrl(payload, next) {

        // Only update if status is differnt
        this.simpleFind({
            urlId: payload.id,
        }, (err, result) => {
            if(err) {
                next(err)
            } else {
                if(result.length === 1 && (result[0].status !== payload.status)) {
                                    
                    var updateField = {
                        status: payload.status,
                        lastRun:  new Date(),
                        processing: false
                    };
            
                    let delta = {
                        "from" : result[0].status,
                        "to" : payload.status,
                        "timestamp" :  new Date()
                    }
            
                    var updatePayload = {
                        query: {
                            urlId: payload.id,
                        },
                        update: {
                            $push: { delta: delta },
                            $set: updateField
                        }
                    };
                    this.update(updatePayload, (err) => {
                        next(err);
                    });

                } else {
                    var updateField = {
                        status: payload.status,
                        lastRun:  new Date(),
                        processing: false
                    };

                    var updatePayload = {
                        query: {
                            urlId: payload.id,
                        },
                        update: {
                            $set: updateField
                        }
                    };

                    this.update(updatePayload, (err) => {
                        next(err);
                    });
                }
            }
        }) 
            
    }

    deleteByUrlId(payload, next) {
        this.simpleFind({
            urlId: payload.id,
        }, (err, result) => {
            if(err) {
                next(err)
            } else {
                if(result[0]) {
                    var id = result[0]._id
                    this.delById(id, (err) => {
                        next(err)
                    })
                } else {
                    next("URL NOT FOUND")
                }
            }
        })
    }

    // db.urls.update({"_id": ObjectId("58bd803abfb038a40b368626")}, {$set: {"status": "TESTT"}})
    // this.update({
    //     query: {"_id": ObjectId("PAYLOAD.ID")}
    //     update: {
    //         $set: {
    //             "status" : PAYLOAD.STATUS
    //         }
    //     }
    // })


    insertUrl(payload, next) {
        var urlId = md5(payload.url);

        var lastRun = new Date();
        lastRun.setDate(lastRun.getDate() - 100);

        var insertPayload = {
            urlId: urlId,
            category: '',
            supplierId: payload.supplierId,
            url: payload.url,
            status: 'NEW',
            lastRun: lastRun
        };

        this.insert(insertPayload, (err) => {
            next(err);
        });
    }

    findSupplierUrls(payload, next) {
        this.find({
            supplierId: payload.id,
            size: payload.size,
            start: payload.skip,
            sort: payload.sort
        }, (err, result) => {
            if (err) {
                next(err);
            } else {
                next(null, result);
            }
        });
    }

    deleteAllUrls(payload, next) {
        var supplierId = payload.id;

        var deletePayload = {
            supplierId
        };
        this.remove(deletePayload, (err) => {
            next(err);
        });
    }

    deleteOneUrl(payload, next) {
        this.delById(payload.id, next);
    }

    findDuplicateUrls(next) {
        var _id = {
            'urlId': '$urlId',
            'supplierId': '$supplierId'
        };


        this.findDuplicates(_id, next);
    }

    findCoverage(payload, next) {
        var newPayload = Object.assign({
            $and: [{
                supplierId: {
                    $in: payload.suppliers
                }
            }],
            $or: [{
                status: 'SEARCH_PAGE1'
            }, {
                status: 'NEW'
            }]
        });

        let timestamp = Math.round(new Date().getTime() / 1000);
        var timePeriod = timestamp - payload.period * 3600;

        if(payload.period !== "all") {
            newPayload.lastRun = {
                $gte: new Date(timePeriod * 1000)
            }
        }

        newPayload.fields = {
            url: 1
        }

        this.find(newPayload, (err, result) => {
            next(err, result);
        });
    }

    /**
     * Split a domain URL into its component parts
     *
     * @param {any} domain
     * @returns {object} domain parts
     * @memberof Url
     */
    parse(domain) {
        if (domain && (domain + '').indexOf('/') > -1 && (domain + '').indexOf(':') > -1) {
            let domainParts = domain.split('/');
            return {
                protocol: domainParts[0].split(':')[0] || 'Unknown',
                host: domainParts[2].split(':')[0] || 'Unknown',
                port: domainParts[2].indexOf(':') > -1 ? domainParts[2].split(':')[1] : 'Unknown',
                path: domainParts.length > 2 ? domainParts.slice(3).join('/').split('?')[0] : '',
                queryString: domainParts.length > 2 ? domainParts.slice(3).join('/').split('?')[1] : '',
                domain: domain
            };

        } else {
            return {
                host: domain,
                domain: domain
            };
        }
    }

}

module.exports = Url;